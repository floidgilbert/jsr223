
\chapter{Software Review}

There are many programming language integrations that combine the strengths of R with other development environments. These language integrations can generally be classified as either \textit{R-major} or \textit{R-minor}. R-major integrations use R as the primary environment to control some other embedded language environment. R-minor integrations are the inverse of R-major integrations. For example, \textbf{rJava} is an R-major integration that allows Java objects to be used within an R session. The Java/R Interface (\textbf{JRI}), in contrast, is an R-minor integration that enables Java applications to embed R.

The \textbf{jsr223} package provides an R-major integration for the Java platform and the \textbf{jsr223} programming languages. In this software review, we provide context for the \textbf{jsr223} project through comparisons with other R-major integrations. Popular R-minor language integrations such as \textbf{Rserve} \citep{rserve} and \textbf{OpenCPU} \citep{opencpu} are not included in this discussion because their objectives and features do not necessarily align with those of \textbf{jsr223}.

Before we discuss individual packages, we point out one unique feature that contrasts \textbf{jsr223} with all other integrations in this discussion: \textbf{jsr223} is the only package that provides a standard interface to integrate R with multiple programming languages. This key feature enables developers to take advantage of solutions and features in several languages without the need to learn or install new packages.

\subsection{\textbf{rJava}}

As noted in the introduction, \textbf{rJava} is the preeminent Java integration for R. It provides a low-level interface to compiled Java classes via the JNI. The \textbf{jsr223} package uses \textbf{rJava} together with the Java Scripting API to create a simple, multi-language integration for the Java platform.

The following code example is taken from \textbf{rJava}'s \href{http://www.rforge.net/rJava/}{web site}. It demonstrates the essential functions of the \textbf{rJava} API by creating and displaying a window with a single button. The first two lines are required to initialize \textbf{rJava}. The next lines use the \texttt{.jnew()} function to create two Java objects: a GUI frame and a button. The associated class names are denoted in JNI syntax. Of particular note is the first invocation of \texttt{.jcall()}, the function used to call object methods. In this case, the \texttt{add()} method of the frame object is invoked. For JNI to identify the appropriate method, an explicit return type must be specified as the second parameter to \texttt{.jcall()} (unless the return value is \texttt{void}). The last parameter to \texttt{.jcall()} specifies the object to be added to the frame object. It must be explicitly cast to the correct interface for the call to be successful.

\singlespace
\begin{verbatim}
library("rJava")
.jinit()
f <- .jnew("java/awt/Frame", "Hello")
b <- .jnew("java/awt/Button", "OK")
.jcall(f, "Ljava/awt/Component;", "add", .jcast(b, "java/awt/Component"))
.jcall(f, , "pack")
# Show the window.
.jcall(f, , "setVisible", TRUE)
# Close the window.
.jcall(f, , "dispose")
\end{verbatim}
\doublespace

The snippet below reproduces the \textbf{rJava} example using JavaScript. In comparison, the JavaScript code is more natural for most programmers to write and maintain. The fine details of method lookups and invocation are handled automatically: no explicit class names or type casts are required. This same example can be reproduced in any of the five other \textbf{jsr223}-supported programming languages.

\singlespace
\begin{verbatim}
var f = new java.awt.Frame('Hello');
f.add(new java.awt.Button('OK'));
f.pack();
// Show the window.
f.setVisible(true);
// Close the window.
f.dispose();
\end{verbatim}
\doublespace

Using \textbf{jsr223}, the preceding code snippet can be embedded in an R script. The first step is to create an instance of a script engine. A JavaScript engine is created as follows:

\singlespace
\begin{verbatim}
library(jsr223)
engine <- ScriptEngine$new("JavaScript")
\end{verbatim}
\doublespace
This engine object is now ready to evaluate script on demand. Source code can be passed to the engine using character vectors or files. The sample below demonstrates embedding JavaScript code in-line with character vectors. This method is appropriate for small snippets of code. (Note: If you try this example the window may appear in the background. Also, the window must be closed using the last line of code. These are limitations of the code example, not \textbf{jsr223}.)

\singlespace
\begin{verbatim}
# Execute code inline to create and show the window.
engine %@% "
  var f = new java.awt.Frame('Hello');
  f.add(new java.awt.Button('OK'));
  f.pack();
  f.setVisible(true);
"

# Close the window
engine %@% "f.dispose();"
\end{verbatim}
\doublespace
To execute source code in a file, use the script engine object's \texttt{source} method:
\begin{verbatim}
engine$source(file.name)
\end{verbatim}
The variable \texttt{file.name} may specify a local file path or a URL. % Whether evaluating small code snippets or sourcing script files, embedding source code using \textbf{jsr223} is straightforward. The ability to embed source code in R facilitates prototyping and promotes rapid application development.

In comparison to \textbf{rJava}'s low-level interface, \textbf{jsr223} allows developers to use Java objects without knowing the details of JNI and method lookups. However, it is important to note that \textbf{rJava} does include a high-level interface for invoking object methods. It uses the Java reflection API to automatically locate the correct method signature. This is an impressive feature, but according to the \textbf{rJava} web site, its high-level interface is experimental and does not work correctly for all scenarios. There are no such limitations for the \textbf{jsr223} scripting languages.

The \textbf{jsr223} languages also feature support for advanced object-oriented constructs. For example, classes can be extended and interfaces can be implemented using any language. These features allow developers to quickly implement sophisticated solutions in R without developing, compiling, and distributing custom Java classes.

The \textbf{rJava} package supports exchanging scalars, arrays, and matrices between R and Java. The following R code demonstrates copying an R matrix to a Java object, and converting it back to an R object using \textbf{rJava}.

\singlespace
\begin{verbatim}
a <- matrix(rnorm(10), 5, 2)
# Copy matrix to a Java object with rJava
o <- .jarray(a, dispatch = TRUE)
# Convert it back to an R matrix.
b <- .jevalArray(o, simplify = TRUE)
\end{verbatim}
\doublespace

Again, the \textbf{jsr223} package builds on \textbf{rJava} functionality by extending data exchange. Our package converts R vectors, factors, n-dimensional arrays, data frames, lists, and environments to generic Java objects.\footnote{\textbf{rJava}'s interface can theoretically support n-dimensional arrays, but currently the feature does not produce correct results for n $>$ 2. See the related issue at the \textbf{rJava} Github repository: ``.jarray(..., dispatch=T) on multi-dimensional arrays creates Java objects with wrong content.''} In addition, \textbf{jsr223} can convert Java scalars, n-dimensional arrays, maps, and collections to base R objects. Several data exchange options are available, including row-major and column-major ordering schemes for data frames and n-dimensional arrays.

This code snippet demonstrates data exchange using \textbf{jsr223}. The variable \texttt{engine} is a \textbf{jsr223} ScriptEngine object. Similar to the preceding \textbf{rJava} example, this code copies a matrix to the Java environment and back again. The same syntax is used for all supported data types and structures.

\singlespace
\begin{verbatim}
a <- matrix(rnorm(10), 5, 2)
# Copy an R object to Java using jsr223.
engine$a <- a
# Retrieve the object.
engine$a
\end{verbatim}
\doublespace

%///not sure this is true about \textbf{JRI} when invoked from \textbf{rJava}. Find out. It could add or remove material here. Could consider showing a \textbf{jsr223} example.
The \textbf{rJava} package does not directly support callbacks into R. Instead, callbacks are implemented through \textbf{JRI}: the Java/R Interface. To use \textbf{JRI}, R must be compiled with the shared library option \texttt{-{}-enable-R-shlib}. \textbf{JRI} also requires several paths and environment variables to be set, so it includes a launch script to get started. The \textbf{JRI} interface is technical and extensive. In contrast, \textbf{jsr223} supports callbacks into R using a lightweight interface that provides just three methods to execute R code, set variable values, and retrieve variable values. The \textbf{jsr223} package does not use \textbf{JRI}, so there is no requirement for R to be compiled as a shared library.

In conclusion, \textbf{jsr223} provides an alternative integration for the Java platform that is easy to learn and use.
