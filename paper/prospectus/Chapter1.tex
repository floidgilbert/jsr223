
\chapter{Introduction}

About the same time Ross Ihaka and Robert Gentleman began developing R at the University of Auckland in the early 1990s, James Gosling and the so-called Green project team was working on a new programming language at Sun Microsystems in California. The Green team didn't set out to make a new language; rather, they were trying to move platform-independent, distributed computing into the consumer electronics marketplace. As Gosling explained, ``All along, the language was a tool, not the end.'' Unexpectedly, the programming language outlived the Green project and flourished into one of the most popular development platforms in computing history. That platform, Java, now powers applications ranging from the enterprise (\href{https://www.google.com/gmail/about/}{GMail}), to games (\href{https://minecraft.net}{Minecraft}), to interactive media (Blue-ray), to mobile devices (\href{https://www.android.com/}{Android}).

In 2003, Simon Urbanek released \textbf{rJava}, an integration package designed to avail R of the burgeoning development surrounding Java. The package has been very successful to this end. Today, it is one of the top-ranked solutions for R as measured by monthly downloads.\footnote{The \textbf{rJava} package ranks in the $95^{\text{th}}$ percentile for R package downloads according to \href{http://rdocumentation.org}{http://rdocumentation.org}.} \textbf{rJava} is described by Urbanek as a low-level R to Java interface analogous to .C and .Call, the built-in R methods for calling compiled C code. Like R's integration for C, \textbf{rJava} loads compiled code into an R process's memory space where it can be accessed via various R methods. Urbanek achieves this feat using the Java Native Interface (JNI), a standard framework that enables native (i.e. platform-dependent) code to access and use compiled Java code. The \textbf{rJava} API requires users to specify classes and data types in JNI syntax. One advantage to this approach is that the user has granular, direct access to Java classes. However, as with any low-level interface, the learning curve is relatively high and implementation requires verbose coding. Another advantage of using JNI is that it avoids the difficult task of dynamically interpreting or compiling source code. Of course, this is also a disadvantage: it limits \textbf{rJava} to using compiled code as opposed to embedding dynamic source code directly within R script.

Our \textbf{jsr223} package builds on \textbf{rJava} to provide a high-level, extended interface to the Java platform. We use the Java Scripting API \citep{jsa} as defined by the specification “JSR-223: Scripting for the Java Platform” \citep{jsr223spec} to provide a unified integration interface to several programming languages. To date, \textbf{jsr223} supports six languages: Groovy, JavaScript, JRuby, Jython, Kotlin, and Scala. (JRuby and Jython are Java implementations of the Ruby and Python languages, respectively.) All of these languages can create and use Java objects. Hence, \textbf{jsr223} enables developers to easily embed other languages in R that can, in turn, use Java classes in natural syntax. As we will show, this approach is easier to use than \textbf{rJava}'s low-level JNI interface. In addition to multi-language support for the Java platform, \textbf{jsr223} provides an intuitive callback API to access R from any of the supported languages. Finally, the \textbf{jsr223} package simplifies and extends data exchange between R and Java. In all, \textbf{jsr223} lowers the barrier to the performance benefits and cross-platform capabilities of the Java platform.

There are three primary use cases for \textbf{jsr223}. Most importantly, any of the \textbf{jsr223} languages can be used to quickly script Java solutions in R. Second, \textbf{jsr223} provides access to solutions developed in any of the \textbf{jsr223} languages. Lastly, the callback interface included with \textbf{jsr223} can be used to embed R within any of the supported languages. This feature does not require linking to R as a shared library. However, it can only be used in scripts (not compiled code).

\subsection{Document organization}

We define some needed terminology, and then we put the \textbf{jsr223} project in context with a review of relevant software. Next, there are the necessary installation instructions and a quick start guide to demonstrate major package features. The most interesting sections follow with code samples that blend R with the \textbf{jsr223} languages. All code samples related to this document are available at \href{http://notavalidaddresss////}{GitHub}.

\section{Helpful terminology and concepts}

Java programs are compiled to Java bytecode that is executed by an instance of a Java Virtual Machine (JVM). The JVM is an abstraction layer that provides a platform-independent execution environment for Java programs. The JVM interprets Java bytecode to machine code (i.e., processor-specific instructions). JVMs are available for a wide variety of hardware and software platforms. In principle, the same Java program will run on any platform that supports a JVM. The Java paradigm contrasts with traditional compiled languages, such as C, that are compiled directly to processor-dependent machine code, and therefore must be recompiled for every targeted architecture. Often, changes in the source code are also required to support different platforms.

Today, there are several programming languages that compile down to Java bytecode including all of the languages currently supported by \textbf{jsr223}. This may be surprising to some readers because languages like JavaScript are traditionally interpreted only, not compiled. In fact, the \textbf{jsr223} languages blur the line between scripting languages (those that are interpret-only), and traditional compiled languages. Nevertheless, we generally refer to the languages supported by \textbf{jsr223} as scripting languages in this document because source code can be interpreted and executed (i.e., evaluated) in one step. Even so, this implementation benefits from the significant performance gains of compiled code.

A \textit{scripting engine} (usually shortened to \textit{script engine}) is software that enables a scripting language to be embedded in an application. Internally, a script engine uses an \textit{interpreter} to parse and execute source code. The terms \textit{script engine} and \textit{interpreter} are often used interchangeably. In this document, \textit{script engine} refers to the software component, not the interpreter. A \textit{script engine instance} denotes an instantiated script engine. Finally, a \textit{script engine environment} refers to the state (i.e., the variables and settings) of a given instance.

\textit{Bindings} refers to the name/value pairs associated with variables in a given scope. Conceptually, a variable's name is bound to its value. The variable names and values in R's global environment are examples of bindings.
