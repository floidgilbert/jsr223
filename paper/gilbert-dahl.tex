% !TeX root = RJwrapper.tex
\title{\pkg{jsr223}: A Simple Interface Between R, Java, and Java-Based Scripting Languages JavaScript, Jython (Python), JRuby (Ruby), and Groovy}
\author{by Floid R. Gilbert and David B. Dahl}

%///update code sample original files. Made a lot of changes in-line.
\maketitle

\abstract{
The R package \pkg{jsr223} is a high-level integration for Java that makes Java objects easy to use from within R and simplifies bi-directional data exchange for a wide variety of objects. Furthermore, \pkg{jsr223} employs the Java Scripting API to bring four scripting languages and, by extension, countless libraries to the R software environment. \pkg{jsr223} uses intuitive syntax to blend JavaScript, Ruby, Python, and Groovy (a Java-like scripting language) with R script. In all, this integration leverages the performance benefits and cross-platform capabilities of the Java Virtual Machine and extends the computing capabilities of the R software environment.
}

\section{Introduction}

%///Discuss popularity/significance of Java.
%///Mention that JSR223 was made part of JRE (use their jargon)

In 2006, Sun Microsystems released the Java Scripting API \citep{jsa} defined by the specification “JSR-223: Scripting for the Java Platform” \citep{jsr223spec}. The JSR-223 specification includes two crucial elements: an interface for Java applications to execute code written in scripting languages, and a guide for scripting languages to create Java objects in their own syntax. Several scripting language projects have adopted JSR-223. Some of the most successful projects to date include JavaScript \citep{jsnashorn}, Jython \citep{jython}, JRuby \citep{jruby}, and Groovy \citep{groovy}. Jython and JRuby are Java implementations of the Python \citep{python} and Ruby \citep{ruby} languages, respectively. Groovy is a scripting implementation of the Java programming language. The Java platform has benefited a great deal from the addition of these scripting languages. Solutions developed in Python, for example, are now accessible to applications on the Java Virtual Machine (JVM). In essence, JSR-223 has facilitated the creation of a larger development ecosystem on the Java platform.

Just as JSR-223 extends the Java platform, our \CRANpkg{jsr223} package extends the R development environment. \pkg{jsr223} uses the Java Scripting API to enable solutions written in JavaScript, Python, Ruby, and Groovy to be embedded within R. The inclusion of Groovy enables programmers to blend natural Java code with R. \pkg{jsr223} also provides simplified access to Java classes through any of these languages by merit of the JSR-223 specification, substantially lowering the barrier for programmers that want to use Java classes in R. In all, \pkg{jsr223} makes countless existing solutions immediately available to R developers and promotes the rapid development of new R solutions that can exploit the Java platform.

\pkg{jsr223} supports extensive data interchange between R, Java and the supported scripting environments. \pkg{jsr223} also features direct calls to scripted functions and methods, script compiling, and a callback interface that provides embedded scripts access to the R environment. Finally, \pkg{jsr223} is easy to install and can be used with any standard R installation.

While there are other R packages that provide integrations for Java, JavaScript, Python, Ruby, and Groovy, \pkg{jsr223} offers a unique combination of features that make it particularly compelling to statistical developers. First and foremost, \pkg{jsr223} offers high-level access to the cross-platform and performance benefits of the Java platform. Second, \pkg{jsr223} exposes a user-friendly programming interface that is consistent across multiple scripting languages. This enables developers to leverage solutions in several languages with a single R package. Third, \pkg{jsr223} reduces complex data exchange operations between R and Java to a simple variable assignment. Data exchange in \pkg{jsr223} is fast and precise (no rounding). \pkg{jsr223} supports the primary data structures in both R and Java. For R, the supported structures are vectors, factors, n-dimensional arrays, data frames, lists, and environments. For Java, scalars, n-dimensional arrays, maps, and collections are supported. Both row-major and column-major ordering are available for data frames and n-dimensional arrays. While existing R packages provide some of these features, none provide all of these features together. We believe that \pkg{jsr223} can significantly extend the computing capabilities of the R software environment with a relatively low learning curve. A detailed discussion of how \pkg{jsr223} compares to other packages is included in \hyperlink{softwarereview}{Software review}.

\pkg{jsr223} is built on \CRANpkg{rJava} \citep{rjava}, the low-level R to Java interface. The design of \pkg{jsr223} follows cues from \pkg{rJava}, \CRANpkg{rscala} \citep{rscala}, and \CRANpkg{V8} \citep{v8pkg}.

\subsection{Document organization}

We start with the necessary installation instructions and a quick start guide to get you up and running. The most interesting sections follow with code samples that blend R with Java, Groovy, JavaScript, Python, and Ruby. Afterwards, we provide a software comparison and a short discussion about the \pkg{jsr223} package design.

All code samples related to this document are available at \href{http://notavalidaddresss////}{GitHub}.

\subsection{Terminology}

A \dfn{scripting engine} (or just \dfn{script engine}) is software that enables a scripting language to be embedded in an application. Internally, a script engine uses an \dfn{interpreter} to parse and execute source code. The terms \dfn{script engine} and \dfn{interpreter} are often used interchangeably which may lead to confusion. In this document, \dfn{script engine} refers to the software component, not the interpreter. A \dfn{script engine instance} denotes an active script engine. Finally, a \dfn{script engine environment} refers to the variables and settings of a given instance.

\dfn{Bindings} refers to the name/value pairs associated with variables in a given scope or environment. Conceptually, a variable's name is bound to its value. The variable names and values in R's global environment are examples of bindings.

\section{Package installation}

\pkg{jsr223} requires Java 8 Standard Edition or above. The current version of the Java Runtime Environment (JRE) can be determined by executing \samp{java -version} from a command prompt or terminal. See the example output below. \strong{Note:} Java 8 is denoted by version 1.8.x\_xx.

\begin{verbatim}
java version "1.8.0_91"
Java(TM) SE Runtime Environment (build 1.8.0_91-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b15, mixed mode)
\end{verbatim}

The JRE can be obtained from  \href{http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html}{Oracle's web site}. Select the architecture (32 or 64 bit) that matches your R installation.

\pkg{jsr223} runs on a standard installation of R (e.g., the R build option \code{--enable-R-shlib} is not required). \pkg{jsr223} is available on CRAN and can be installed with the usual command:

\begin{verbatim}
install.packages("jsr223")
\end{verbatim}

\hypertarget{scriptengineinstallation}{\section{Script engine installation}}

To create an instance of a language's script engine, \pkg{jsr223} requires access to the associated script engine libraries. These instructions will help you obtain these libraries in the form of a standalone Java Archive (JAR) file. Though it is possible to use a full language installation with \pkg{jsr223} instead of a standalone file, those instructions are not included here for the sake of simplicity and portability.

\subsection{Groovy}

\href{http://groovy-lang.org}{Groovy} is a Java-like language enhanced with modern dynamic programming features. Java code can often be executed by the Groovy engine with little modification. In essence, our integration with Groovy brings the Java language to R.

To obtain the standalone Groovy engine, go to \url{http://groovy-lang.org} and click the \samp{Download} link. Locate the current binary distribution. Download and extract the archive to a temporary folder. Locate the \samp{embeddable} subfolder. Copy the file named \samp{groovy-all-x.x.x.jar} to a convenient location and make note of the path. This path will be used by \pkg{jsr223} to load the script engine.

\subsection{JavaScript (Nashorn)}

\href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Nashorn} is the JavaScript dialect included in Java 8. Nashorn implements ECMAScript 5.1. No download is required to use JavaScript with \pkg{jsr223}. Technical documentation and examples for Nashorn are available at \href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Oracle's web site}.

\subsection{JRuby}

\href{http://jruby.org}{JRuby} is a Java-based implementation of the Ruby programming language. Obtain the standalone JRuby engine by clicking the \samp{Downloads} link at at \url{http://jruby.org}. Find \samp{JRuby x.x.x.x Complete.jar} and save it to a convenient location. Make note of the path; it will be used by \pkg{jsr223} to load the script engine.

\subsection{Jython}

\href{http://www.jython.org}{Jython} is a Java-based implementation of the Python programming language. The standalone Jython engine is available at \url{http://www.jython.org}. Follow the \samp{Download} link. Click \samp{Download Jython x.x.x - Standalone Jar} to start the download. Save the JAR file to a convenient location and remember the path. This path will be used by \pkg{jsr223} to load the script engine.

\section{Quick start guide}

The primary features of \pkg{jsr223} are designed to be accessible to R programmers of all experience levels. This quick start guide illustrates these features with simple code examples. Unless otherwise stated, code samples in this section should work for all of the supported scripting languages with one exception: global objects in Ruby script must be prefixed with a dollar sign.

\subsection{Hello world}

This R code snippet demonstrates the basic elements required to embed a scripting language: start a script engine, optionally pass data to the script engine environment, execute a script, and terminate the script engine when it is no longer needed.

%///replace all verbatim with example or whatever it is that R Journal uses.
\begin{verbatim}
library("jsr223")
engine <- ScriptEngine$new("javascript")
engine$message <- "Hello world"
engine %~% "print(message);"

## Hello world

engine$terminate()
\end{verbatim}

The \code{ScriptEngine\$new} constructor method creates a script engine instance. In the preceding example, we assign the new script engine object to the variable \code{engine}. The first argument of \code{ScriptEngine\$new} specifies the type of script engine to create. In this case, we create a JavaScript engine. The third line assigns the value \code{"Hello world"} to a global variable named \code{message} in the script engine environment. The next line executes a JavaScript code snippet using the \code{\%$\sim$\%} operator. The snippet uses the JavaScript \code{print} method to write the message to the console. The last line in the example terminates the script engine and releases the associated resources.

To create a script engine other than JavaScript, specify a different script engine name and a path to the required script engine JAR file. (See \hyperlink{scriptengineinstallation}{Script engine installation} for instructions to obtain a script engine JAR file.) The supported script engine names are listed in Table \ref{tab:script-engine-type-names}. These names are defined by the script engine provider. \strong{Note:} Script engine names are case sensitive.

The next example reproduces the “Hello world” example in Ruby script.

\begin{verbatim}
library("jsr223")
engine <- ScriptEngine$new(
  engine.name = "ruby",
  class.path = "../engines/jruby-complete.jar"
)
engine$message <- "Hello world"
engine %~% "puts $message"

## Hello world

engine$terminate()
\end{verbatim}

In this case, two parameters are passed to the \code{ScriptEngine\$new} method: the script engine name \code{"ruby"}, and the path to the JRuby script engine JAR file. As before, we assign the value \code{"Hello world"} to a global variable named \code{message} and print it to the console. Notice that we prefix the global variable with a dollar sign: \code{\$message}. This syntax is peculiar to global variables in the Ruby language.

\begin{table}[h]
    \small
    \centering
    \begin{tabular}{l p{8cm}}
        \toprule
        \textbf{Language} & \textbf{Script engine names} \\
        \midrule
        \noalign{\vspace{1ex}}
        \href{http://groovy-lang.org}{Groovy} &  \code{groovy}, \code{Groovy}\\[.25cm]
        \href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{JavaScript (Nashorn)} & \code{js}, \code{JS}, \code{JavaScript}, \code{javascript}, {nashorn}, \code{Nashorn}, \code{ECMAScript}, \code{ecmascript}\\[.25cm]
        \href{http://jruby.org}{JRuby (Ruby)} & \code{jruby}, \code{ruby}\\[.25cm]
        \href{http://www.jython.org}{Jython (Python)} & \code{jython}, \code{python}\\[.25cm]
        \noalign{\vspace{1ex}}
        \bottomrule
    \end{tabular}
    \caption{The \code{ScriptEngine\$new} constructor method creates a new script engine instance for a given language using the names in this table. The names are case sensitive.}
    \label{tab:script-engine-type-names}
\end{table}

\subsection{Executing script}

\pkg{jsr223} provides several methods to execute script. The lines

\begin{verbatim}
return.value <- engine %~% script
return.value <- engine$eval(script)
\end{verbatim}

\noindent both evaluate the expression in the character vector \code{script}. The return value is the result of the last expression in the script, if any, or \code{NULL} otherwise. Text written to standard output by the script engine is printed to the R console. The following line executes JavaScript code and assigns the result to an R variable.

\begin{verbatim}
result <- engine %~% "isFinite(1);"
\end{verbatim}

The following lines also execute script, but there are no return values. This notation is convenient if the last expression in the snippet returns unneeded data or an unsupported type.

\begin{verbatim}
engine %@% script
engine$eval(script, discard.return.value = TRUE)
\end{verbatim}

\noindent To execute a script file, use either of the following lines where \code{filename} is the path to the script file.

\begin{verbatim}
engine$source(filename)
engine$source(filename, discard.return.value = TRUE)
\end{verbatim}

The methods \code{eval} and \code{source} take an argument named \code{bindings} that accepts an R named list. The name/value pairs in the list replace the script engine's global bindings during script execution. The following example demonstrates this functionality. Notice that the result of \code{a + b} changes when bindings are specified.

\begin{verbatim}
engine$a <- 2
engine$b <- 3
engine$eval("a + b")

## 5

lst1 <- list(a = 6, b = 7)
engine$eval("a + b", bindings = lst1)

## 13

lst2 <- list(a = 6)
# This line would throw an error because 'b' is no longer defined.
## engine$eval("a + b", bindings = lst2)

# When 'bindings' is not specified, the script engine reverts to the default
# global bindings.
engine$eval("a + b")

## 5
\end{verbatim}

\subsection{Sharing data between language environments}

The following two lines of R code are equivalent: they convert an R object to a Java object and assign the new object to a global variable named \code{"myValue"} in the script engine's environment. This syntax is the same for all supported R data structures.

\begin{verbatim}
engine$myValue <- iris
engine$set("myValue", iris)
\end{verbatim}

To retrieve \code{myValue} from the script engine (i.e., to convert a Java object to an R object), use either of the following lines.

\begin{verbatim}
engine$myValue
engine$get("myValue")
\end{verbatim}

Remove the \code{myValue} variable with \code{engine\$remove("myValue")}. List all global variables in the script engine's environment with \code{engine\$getBindings()}.

All data structures in Java-based scripting languages are backed by Java objects. Discover the Java class for any global variable using  \code{engine\$getJavaClassName("identifier")} where \code{identifier} is the variable's name.

Behind the scenes, \pkg{jsr223}'s simplified data exchange is provided by \CRANpkg{jdx}: Java Data Exchange for R and \pkg{rJava}. The \pkg{jdx} package's functionality was originally part of \pkg{jsr223}, but it was broken out into a separate package to simplify maintenance and to make its features available to other developers.

The \pkg{jdx} package (and hence \pkg{jsr223}) supports converting R vectors, factors, n-dimensional arrays (such as matrices), data frames, named lists, unnamed lists, nested lists (i.e., lists containing lists), and environments to generic Java objects. Row-major and column-major ordering options are available for both arrays and data frames. R data types numeric, integer, character, raw, and logical are supported. Complex types and date/time classes are not supported: convert them to character vectors.

Java scalars, n-dimensional arrays, collections, and maps can be converted to standard objects in the R environment. The supported Java structures cover all of the primary types used in the supported scripting languages. Moreover, collections and maps are ubiquitous in Java APIs; providing support for these structures gives R developers easy access to a vast number of data structures available on the Java platform.

All of the \pkg{jdx} data conversion options are mirrored by settings in \pkg{jsr223}. The most pertinent details are discussed in the following sections including \hyperlink{dataexchangedetails}{Data exchange details}. For a more thorough, low-level discussion, see the vignette included with the \pkg{jdx} package. 

\subsection{Setting and getting script engine options}

The \pkg{jsr223} \code{ScriptEngine} class exposes several methods that control settings for a script engine instance. These methods are named using the Java getter/setter convention: methods that set values are prefixed with ``set'' and methods that retrieve values begin with ``get''. For example, if \code{engine} is a script engine object, \code{engine\$setArrayOrder('column-major')} will change the \textit{array order} setting. The code \code{engine\$getArrayOrder()} will retrieve the current \textit{array order} setting.

\hypertarget{handlingrvectors}{\subsection{Handling R vectors}}

By default, length-one R vectors are converted to Java scalars when passed to the script engine environment. If a Java length-one array is desired, wrap the value in the R ``as-is'' function (e.g., \code{I(myValue)}), or set the \textit{length one vector as array} setting to \code{TRUE} using the \code{setLengthOneVectorAsArray} method. The following example demonstrates converting length-one vectors.

\begin{verbatim}
# By default, length-one vectors are converted to Java scalars.
engine$setLengthOneVectorAsArray(FALSE)
engine$myScalar <- 1
engine$getJavaClassName("myScalar")

## [1] "java.lang.Double"

# Wrap the vector in I() to indicate that an array should be created instead.
# The resulting Java class name is "[D" which denotes a primitive, double 
# one-dimensional array.
engine$myArray <- I(1)
engine$getJavaClassName("myArray")

## [1] "[D"

# To change the conversion behavior for all length-one vectors, set the 
# 'length one vector as array' setting to TRUE.
engine$setLengthOneVectorAsArray(TRUE)
engine$myArray <- 1
engine$getJavaClassName("myArray")

## [1] "[D"
\end{verbatim}

Vectors of any length other than one are always converted to primitive Java arrays. The following code passes a vector of ten random normal deviates to the script engine environment. The first element of the resulting array is returned. This syntax is common to all of the supported scripting languages. \strong{Note:} Java arrays use zero-based indexes.

\begin{verbatim}
set.seed(10)
engine$norms <- rnorm(10)
engine %~% "norms[0]"

## [1] 0.01874617
\end{verbatim}

\subsection{Handling R matrices and other n-dimensional arrays}

By default, n-dimensional arrays are copied in row-major order. The following example demonstrates converting a simple 2 x 2 R matrix. Because the order is row-major, the last line of code returns the element in the first row, second column. Remember, Java arrays use zero-based indexes.

\begin{verbatim}
m <- matrix(1:4, 2, 2)
m

##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4

engine$m <- m
engine %~% "m[0][1]"

## [1] 3
\end{verbatim}

The \code{setArrayOrder} script engine method controls index ordering for arrays converted from R to Java, and vice versa. Three array index ordering schemes are available: \code{'row-major'}, \code{'column-major'}, and \code{'row-major-java'}. Before describing these schemes, it is helpful to think of n-dimensional arrays as collections of smaller structures. A one-dimensional array (a vector) is a collection of scalars. A two-dimensional array (a matrix) is a collection of one-dimensional arrays representing either rows or columns of a matrix. A three-dimensional array (a rectangular prism or cube) is a collection of matrices. A four-dimensional array is a collection of cubes, and so forth. Java n-dimensional arrays are literally constructed in this fashion. R n-dimensional arrays, on the other hand, are stored in memory as a vector and the data is retrieved in the appropriate order using indexing arithmetic.

Now we describe the each of the array indexing options.

\begin{itemize}
\item \strong{row-major} -- The indexes of an n-dimensional array are ordered \newline\code{[row][column][matrix]...[n]}. The \pkg{jsr223} package defaults to 'row-major' because R uses this scheme. However, this scheme is not intuitive for Java programmers when n > 2 because Java n-dimensional arrays are constructed as higher-order objects containing lower-order objects.

\item \strong{column-major} -- The indexes of an n-dimensional array are ordered \newline\code{[n]...[matrix][column][row]}. This ordering scheme is natural for Java programmers because this is the order that Java arrays are literally constructed. The data contained at the one-dimensional level represent columns of the parent matrix.

\item \strong{row-major-java} -- The indexes of an n-dimensional array are ordered \newline\code{[n]...[matrix][row][column]}. This is similar to the \code{'column-major'} ordering scheme except that the arrays at the one-dimensional level represent rows of the parent matrix. For matrices, 'row-major-java' and 'row-major' are equivalent.

\end{itemize}

\strong{Note:} Always use the same array ordering scheme when transferring the same array data back and forth between R and Java. For example, if an R array is converted to Java using column-major ordering, and then converted back from Java to R using row-major ordering, the R array will be in the wrong order.

In the following JavaScript example, a three-dimensional array is copied to the script engine using each of the three indexing options. In each case, the Java static method \code{deepToString} creates a string representation of the array to show the resulting order of the data in the script engine.

\begin{verbatim}
a <- array(1:8, c(2, 2, 2))
a

## , , 1
## 
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    5    7
## [2,]    6    8

engine$setArrayOrder("row-major")
engine$a <- a
engine %~% "java.util.Arrays.deepToString(a);"

## [1] "[[[1, 5], [3, 7]], [[2, 6], [4, 8]]]"

engine$setArrayOrder("column-major")
engine$a <- a
engine %~% "java.util.Arrays.deepToString(a);"

## [1] "[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"

engine$setArrayOrder("row-major-java")
engine$a <- a
engine %~% "java.util.Arrays.deepToString(a);"

## [1] "[[[1, 3], [2, 4]], [[5, 7], [6, 8]]]"
\end{verbatim}

\hypertarget{handlingrdataframes}{\subsection{Handling R data frames}}

R data frames can be converted to the script engine using either row-major or column-major order. Row-major order (the default) creates a list of records. This representation is perhaps the most common in programming for tabular data. Column-major order, on the other hand, creates a list of columns. Column-major structures are faster to create and are generally preferred for aggregate column calculations. Change the \textit{data frame order} setting with the \code{setDataFrameRowMajor} method.

When the row-major setting is selected (i.e., \code{engine\$setDataFrameRowMajor(TRUE)}), an R data frame is converted to a \href{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html}{\code{java.util.ArrayList}} object. The list contains  \href{https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html}{\code{java.util.HashMap}} objects that represent the rows of the data frame. Each member of the hash map is a name/value pair of a single field in the data frame. The name of the field is the corresponding column's name. The following example uses R's built-in \code{iris} data set to illustrate using row-major data frames in the script environment. This syntax is the same for all scripting languages. (Remember to prefix the global variables with \code{\$} in Ruby).

\begin{verbatim}
engine$setDataFrameRowMajor(TRUE)
engine$iris <- iris

# Return the number of rows.
engine %~% "iris.size()"

## [1] 150

# Retrieve the sepal length in the first row.
engine %~% "iris[0].get('Sepal.Length')"

## [1] 5.1

# Retrieve the second row as a list.
engine %~% "iris[1]"

## $`Sepal.Length`
## [1] 4.9
## 
## $Sepal.Width
## [1] 3
## 
## $Petal.Length
## [1] 1.4
## 
## $Petal.Width
## [1] 0.2
## 
## $Species
## [1] "setosa"
\end{verbatim}

When the column-major setting is selected (i.e., \code{engine\$setDataFrameRowMajor(FALSE)}), an R data frame is converted to a \href{https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html}{\code{java.util.HashMap}} object. The map members are arrays representing the columns in the data frame. The following commented example uses R's built-in \code{mtcars} data set to illustrate basic functionality. This syntax is supported for all scripting languages.

\begin{verbatim}
engine$setDataFrameRowMajor(FALSE)

# 'mtcars' is an R data frame containing information for 32 cars. 'mtcars'
# stores vehicle names as row names. Row names are not preserved during
# conversion. This line creates a new R data frame with the vehicle names as
# a new column 'name'.
df <- data.frame(name = row.names(mtcars), mtcars)

# This line converts the new data frame to a Java map named 'mtcars'.
engine$mtcars <- df

# Return the number of columns in the map.
engine %~% "mtcars.size()"

## [1] 12

# Access each column using the map's 'get' method and the column's name. This
# line returns the first element of the column 'name'.
engine %~% "mtcars.get('name')[0]"

## [1] "Mazda RX4"

# Add a new column named 'cylsize' representing the size of a single cylinder.
engine$cylsize <- mtcars[, "disp"] / mtcars[, "cyl"]
engine %@% "mtcars.put('cylsize', cylsize)"

# Remove the columns 'name' and 'cylsize'.
engine %@% "mtcars.remove('name')"
engine %@% "mtcars.remove('cylsize')"

# Compare the contents of the map to the original data frame in R.
all.equal(mtcars, engine$mtcars, check.attributes = FALSE)

## [1] TRUE
\end{verbatim}

Groovy and JavaScript support an additional syntax that allows map elements to be accessed like object properties instead of using the \code{get} and \code{put} methods.

\begin{verbatim}
# The following two lines are equivalent in Groovy and JavaScript.
engine %~% "mtcars.cyl[0];"
engine %~% "mtcars.get('cyl')[0];"
\end{verbatim}

\subsection{Handling R factors}

R factors are comprised of a character vector of levels and an integer vector of indexes that reference the levels. For example, if the integer vector \code{5:7} is converted to a factor, the levels will be \code{c("5", "6", "7")} and the indexes will be \code{c(1L, 2L, 3L)}. The script engine \textit{coerce factors} setting determines how the factor levels are handled when converting the factor to a Java array. When this setting is enabled (e.g., \code{engine\$setCoerceFactors(TRUE)}), an attempt is made to coerce the factor levels to integer, numeric, or logical values. If coercion fails, the character levels are used. When \textit{coerce factors} is disabled, the factor is always converted to a string array. The \textit{coerce factors} setting applies to standalone factors as well as factors in data frames.

After \pkg{jsr223} converts an R factor to a Java array, there is no consistent way to determine whether the array was originally created from an R factor. Therefore, if an R factor is copied to the script engine, and then the resulting array is returned to R, it will be converted to an R vector, not a factor.

When creating a data frame in R, character vectors are converted to factors by default. The \pkg{jsr223} package follows this standard when a qualifying Java object is converted to an R data frame. The \code{setStringsAsFactors} method modifies this behavior. The method takes one of three values: \code{NULL}, \code{TRUE}, and \code{FALSE}. If \code{NULL} is specified (the default), the R system setting is used (see \newline\code{getOption("stringsAsFactors")}). A value of \code{TRUE} ensures that character vectors are always converted to factors for new data frames. Finally, a setting of \code{FALSE} disables conversion to factors.

\subsection{Handling R lists and environments}
The \pkg{jsr223} package converts R lists and environments to Java objects. List elements may be any R data structure supported by \pkg{jsr223}, including other lists (i.e., nested lists). There is no limitation to the levels of nesting.

R named lists and environments are converted to Java \href{https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html}{\code{java.util.HashMap}} objects. See \hyperlink{handlingrdataframes}{Handling R data frames} for map code examples. The only difference is that a data frame's contents are always converted to a map of arrays. For lists, the map elements may be any data structure.

R unnamed lists are converted to Java objects implementing the \href{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html}{\code{java.util.ArrayList}} interface. The following code demonstrates basic \code{java.util.ArrayList} functionality.

\begin{verbatim}
# Create an unnamed list with three elements.
engine$list <- list(c("a", "b", "c"), TRUE, pi)

# Members in the list are accessed by index. This line returns the first element.
engine %~% "list[0]"

## [1] "a" "b" "c"

# Replace an element in the list.
engine %@% "list[0] = 'replaced'"

# Add a new element to the end of the list.
engine %@% "list.add('last item')"

# Insert a new item before the first item.
engine %@% "list.add(0, 'first item')"

# Remove the last item.
engine %@% "list.remove(list.size() - 1)"

# Return the number of elements
engine %~% "list.size()"

## [1] 4
\end{verbatim}

\subsection{Data exchange details}

So far, we have discussed all of the basic functionality and settings related to data exchange. This section includes a few additional notes for data exchange. For a comprehensive guide, including potentially unexpected conversion behaviors, see the \pkg{jdx} package vignette.

R reserves special \code{NA} values to indicate missing types. Table \ref{tab:r-na-behavior} outlines how \code{NA} values are handled for different R data types. Table \ref{tab:java-null-behavior}, in turn, describes how Java null values are interpreted when converting Java objects to R.

\begin{table}[b]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
R Structure      & NA Behavior                                         \\ \midrule
\code{numeric}   & \code{NA\_real\_} maps to a reserved value.           \\[.25cm]
\code{integer}   & \code{NA\_integer\_ maps} to a reserved value.        \\[.25cm]
\code{character} & \code{NA\_character\_} maps to Java \code{null}.      \\[.25cm]
\code{logical}   & \code{NA} maps to Java \code{false} with a warning. \\ \bottomrule
\end{tabular}
\caption{R reserves special \code{NA} values to indicate missing types. This table outlines how \code{NA} values are converted to Java values.}
\label{tab:r-na-behavior}
\end{table}

Because \pkg{jsr223} converts data to generic Java data structures, R attributes such as names cannot always be included in conversion. For example, R vectors are converted to native Java arrays, therefore names associated with vector elements must be discarded. Likewise, dimension names are not preserved for n-dimensional structures. Column names for data frames are preserved, but row names are not. To preserve data frame row names, simply copy the names to a new column before converting the data frame.

The \pkg{jsr223} package always converts R vectors and arrays to Java arrays. Java arrays are intuitive to use in all of the supported scripting environments. However, the supported scripting languages can also create array structures that are not native Java arrays. \pkg{jsr223} also supports converting these language-specific array and collection structures to R vectors and arrays.

Java n-dimensional arrays whose subarrays of a given dimension are not the same dimension are known as \dfn{ragged arrays}. Ragged arrays cannot be converted to R arrays. Instead, \pkg{jsr223} translates ragged arrays to lists of the appropriate object. For example, a matrix containing subarrays of different lengths will be converted to an R list of vectors. Likewise, a three-dimensional array containing two matrices of different dimensions will be converted to an R list of matrices.

As described earlier, R unnamed lists are converted to \href{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html}{\code{java.util.ArrayList}} objects. The \code{ArrayList} class implements the \href{https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html}{\code{java.util.Collection}} interface. This is one of the most basic interfaces in Java and it is common to a large number of structures. \pkg{jsr223} converts Java objects implementing the \code{java.util.Collection} interface to vectors, n-dimensional arrays, data frames, and unnamed lists, depending on the structure's content. In some cases an R list converted to a Java object, and then converted back to an R object, may not produce an R list. See the sections ``Java Collections'' and ``Conversion Issues'' in the \pkg{jdx} package vignette for conversion rules and in-depth explanations.

The jdx package converts R raw values to Java byte values and vice versa. R raw values and Java byte values are both 8 bits, but they are interpreted differently. R raw values range from 0 to 255 (i.e., unsigned bytes). Java byte values range from -128 to 127 (i.e., signed bytes). The 8-bit value 0xff represents 255 in R, but is -1 in Java. Usually this discrepancy is not an issue because raw and byte values are used to store and transfer binary data such as images. If human-readable values are important, use integer vectors instead.

\begin{table}[t]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Java Structure                             & Java null Behavior                                             \\ \midrule
\code{Boolean[]..[]} & \code{null} maps to \code{FALSE} with a warning.           \\[.25cm]
\code{Byte[]..[]}       & \code{null} maps to \code{raw} \code{0x00} with a warning. \\[.25cm]
\code{Character[]..[]}  & \code{null} maps to \code{NA\_character\_}.                \\[.25cm]
\code{Double[]..[]}   & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Float[]..[]}     & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Integer[]..[]}     & \code{null} maps to \code{NA\_integer\_}.                  \\[.25cm]
\code{java.math.BigDecimal[]..[]}          & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{java.math.BigInteger[]..[]}          & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Long[]..[]}       & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Object[]..[]}                        & \code{null} maps to \code{NULL}.                           \\[.25cm]
\code{Short[]..[]}     & \code{null} maps to \code{NA\_integer\_}.                  \\[.25cm]
\code{java.lang.String[]..[]}              & \code{null} maps to \code{NA\_character\_}.                \\ \bottomrule
\end{tabular}
\caption{Java \code{null} indicates missing or uninitialized values. This table outlines how \code{null} is interpreted when converting Java objects to R.}
\label{tab:java-null-behavior}
\end{table}

\subsection{Calling script functions and methods}

Functions and methods defined in script can be called directly from R via the \code{invokeFunction} and \code{invokeMethod} script engine methods. Any number of supported R structures can be passed as parameter values.

\strong{Note:} The Groovy and Python engines can use \code{invokeMethod} to call methods of Java objects. The JavaScript and Ruby engines only support calling methods of native scripting objects.

As described in \hyperlink{handlingrvectors}{Handling R vectors}, length-one vectors are converted to Java scalars by default. One way to ensure that a vector is always converted to a Java array is by wrapping it in the ``as-is'' function \code{I()}. This feature is particularly useful when passing multiple parameters to a script function. In the same function, some parameters may require scalars while others require arrays. Simply use \code{I()} to indicate which vectors should be converted to arrays.

The following example demonstrates calling a simple JavaScript function, \code{sumThis}, that sums the elements of an array. If the first parameter is not an array, the function throws an error.

\begin{verbatim}
# Define a simple global function 'sumThis'.
engine %@% "
function sumThis(a) {
  if (!a.getClass().isArray())
    throw 'Not an array.';
  sum = 0;
  for (i = 0; i < a.length; i++) { 
      sum += a[i];
  }  
  return sum;
}
"

# Set the default length-one vectors setting so the example works as intended.
engine$setLengthOneVectorAsArray(FALSE)

# Call the function with a vector with length > 1.
vector <- c(1, 2, 3)
engine$invokeFunction("sumThis", vector)

## [1] 6

# If the vector is length-one, an error is thrown because an array parameter
# is expected.
vector <- 1
engine$invokeFunction("sumThis", vector)

## javax.script.ScriptException: Not an array. in <eval> at line number 4 at
## column number 4

# Try again, this time marking the vector as-is, meaning that it should 
# always be converted to an array.
vector <- 1
engine$invokeFunction("sumThis", I(vector))

## [1] 1
\end{verbatim}

The next example demonstrates using \code{invokeMethod}. It is essentially the same as \code{invokeFunction} except that the first two parameters require the object's name and method, respectively.

\begin{verbatim}
# Invoke the 'abs' (absolute value) method of the JavaScript 'Math' object.
engine$invokeMethod("Math", "abs", -3)

## [1] 3
\end{verbatim}

\subsection{String interpolation}

\pkg{jsr223} features string interpolation before code evaluation. R code placed between \code{@\{} and \code{\}} in a code snippet is evaluated and replaced by the a string representation of the return value before the snippet is executed by the script engine. A script may contain multiple \code{@\{...\}} expressions. String interpolation is enabled by default. It can be disabled using \code{engine\$setInterpolation(FALSE)}.

\strong{Note:} Interpolated decimal values may lose precision when coerced to a string.

This example simply sums two numbers. The section \hyperlink{callbacks}{Callbacks} includes a more interesting interpolation example involving recursion.

\begin{verbatim}
a <- 1; b <- 2
engine %~% "@{a} + @{b}"

## 3
\end{verbatim}

Interpolation expressions are evaluated in the current scope. The following example shows that interpolation locates the value defined in the function's scope before the global variable of the same name.

\begin{verbatim}
a <- 1

constantFunction <- function() {
  a <- 3
  engine %~% "@{a}"
}

constantFunction()

## [1] 3
\end{verbatim}

\hypertarget{callbacks}{\subsection{Callbacks}}

Embedded scripts can access the R environment using the \pkg{jsr223} callback interface. When a script engine is started, \pkg{jsr223} creates a global object named \code{R} in the script engine's environment. This object is used to execute R code and set/get variables in the R session's global environment.

This code example demonstrates setting and getting a variable in the R environment. For Ruby, remember to prefix the global variable \code{R} with a dollar sign.

\begin{verbatim}
engine %@% "R.set('a', [1, 2, 3])"
engine %~% "R.get('a')"

## [1] 1 2 3
\end{verbatim}

\strong{Note:} Changing any of the data exchange settings will affect the behavior of the callback interface. For example, using \code{engine\$setLengthOneVectorAsArray(TRUE)} will cause \code{R.get("pi")} to return an array with a single element instead of a scalar value.

Execute R script with \code{R.eval(script)} where \code{script} is a string containing R code. This example returns a single random normal draw from R.

\begin{verbatim}
set.seed(10)
engine %~% "R.eval('rnorm(1)')"

## [1] 0.01874617
\end{verbatim}

Infinite recursive calls between R and the script engine are supported. The only limitation is available stack space. The following code demonstrates recursive calls and string interpolation with a countdown.

\begin{verbatim}
recursiveCountdown <- function(start.value) {
  cat("T minus ", start.value, "\n", sep = "")
  if (start.value > 0)
    engine %~% "R.eval('recursiveCountdown(@{start.value - 1})');"
}

engine %~% "R.eval('recursiveCountdown(3)')"

## T minus 3
## T minus 2
## T minus 1
## T minus 0
\end{verbatim}

\subsection{Embedding R in another scripting language}

It is often desirable to use R as an embedded language. Though \pkg{jsr223} does not provide a standalone interface to call into R, the same functionality can be achieved with the \code{RScript} command line executable, a simple launch script, and the \pkg{jsr223} callback interface. The following R script is an example of a launch script for Groovy. It executes any Groovy script file provided as a command line parameter.

\begin{verbatim}
library("jsr223")
engine <- ScriptEngine$new("groovy", "../engines/groovy-all.jar")
tryCatch (
  engine$source(commandArgs(TRUE)[1], discard.return.value = TRUE),
  error = function(e) { cat(e$message, "\n", sep = "") },
  finally = { engine$terminate() }
)
\end{verbatim}

The following command line uses the launch script to execute a Groovy script. The launch script is named \samp{groovy-launcher.R} and \samp{source.groovy} is an arbitrary Groovy source file.

\begin{verbatim}
RScript groovy-launcher.R source.groovy
\end{verbatim}

With this setup, a developer can author a Groovy script in a dedicated script editor. The Groovy script can embed R using the \pkg{jsr223} callback interface as if it were a standalone interface. The command line above can be provided to a code editor to execute the Groovy script on demand. The Groovy code below is an example of embedding R.

\begin{verbatim}
// Set a variable named 'probabilities' in the R global environment.
R.set('probabilities', [0.25, 0.5, 0.20, 0.05]);

// Take a random draw of size two using the given probabilities.
draws = R.eval('sample(4, 2, prob = probabilities)');
\end{verbatim}

\subsection{Compiling script}

The Java Scripting API supports compiling script to Java byte code before evaluation. If unstructured code (i.e., code not encapsulated in methods or functions) is to be executed repeatedly, compiling it will improve performance.

\pkg{jsr223} supports compiling code snippets and source files. Both of these lines return a compiled script object:

\begin{verbatim}
cs <- engine$compile(script)
cs <- engine$compileSource(filename)
\end{verbatim}

The compiled script object has a single method, \code{eval}, that is used to execute the compiled code. It can be argued that the method should be called \code{exec} in this case, but our interface follows the Java Scripting API naming scheme. The following is a trivial example that demonstrates the compiled script interface.

\begin{verbatim}
# Compile a code snippet.
cs <- engine$compile("c + d")

# This line would throw an error because 'c' and 'd' have not yet been declared.
## cs$eval()

engine$c <- 2
engine$d <- 3
cs$eval()

## 5

# Supply new bindings...
l1 <- list(c = 6, d = 7)
cs$eval(bindings = l1)

## 13

# When 'bindings' is not specified, the script engine reverts to the original
# environment.
cs$eval()

## 5

# The following line executes the code but discards the return value.
cs$eval(discard.return.value = TRUE)
\end{verbatim}

\subsection{Handling console output}

When script is evaluated, any text printed to standard output appears in the R console by default. Console output can be disabled entirely with \code{engine\$setStandardOutputMode('quiet')}. To resume printing output to the console, use \code{engine\$setStandardOutputMode('console')}.

Text printed to the console by a script engine cannot be captured using R's \code{sink} or \code{capture.output} methods. The following JavaScript example demonstrates how to capture output using the \textit{standard output mode} \code{'buffer'} option.

\begin{verbatim}
# Set output mode to 'buffer' to capture text written to standard output.
engine$setStandardOutputMode("buffer")

# The JavaScript print method writes text to standard output followed by a new
# line. This output will not appear in the R console; it will be stored in an
# internal buffer.
engine %@% ("print('abc');")

# 'getStandardOutput' retrieves the buffer as a character vector and clears the
# buffer.
engine$getStandardOutput()

## [1] "abc\n"

# Alternatively, the buffer can be discarded using 'clearStandardOutput'.
engine %@% ("print('abc');")
engine$clearStandardOutput()

# Restore console printing.
engine$setStandardOutputMode("console")

# The current output mode is retrieved using 'getStandardOutputMode'.
engine$getStandardOutputMode()

## [1] "console"
\end{verbatim}

\subsection{Console mode: a simple REPL}

\pkg{jsr223} provides a simple read-evaluate-print-loop (REPL) for interactive code execution. This feature is inspired by Jeroen Ooms's \pkg{V8} package. The REPL is useful for quickly setting and inspecting variables in the script engine. Returned values are printed to the console using \code{base::dput}. The \code{base::cat} function is not used because it cannot handle complex data structures.

Use \code{engine\$console()} to enter the REPL. Enter \samp{exit} to return to the R prompt. The REPL supports only single line entry: no line continuations or carriage returns are allowed. This limitation arises from the fact that the Java Scripting API does not support code validation.

The following output was produced by a Python REPL session. The code creates a Python dictionary object and accesses the elements. The tilde character (\samp{$\sim$}) indicates a prompt.

\begin{verbatim}
python console. Press ESC, CTRL + C, or enter 'exit' to exit the console.
~ dict = {"first": 1, "second": 2}

~ dict["first"]
1
~ dict["second"]
2
~ exit
Exiting console.
\end{verbatim}

Most developers are familiar with the command history in the R REPL.  Unfortunately, this feature is unreliable in the \pkg{jsr223} REPL because there is no standard for saving and restoring commands in R consoles.

\section{R with Groovy}

\href{http://www.groovy-lang.org/}{Groovy} is a dynamic programming language that closely follows Java syntax. The \pkg{jsr223} integration for Groovy enables developers to write solutions for R in natural Java syntax. Differences between Java and Groovy syntax are described in the Groovy guide “\href{http://groovy-lang.org/differences.html}{Differences with Java}” ///cite?.

\strong{Note:} In Groovy script, top-level variables will not persist in the script engine environment unless they are explicitly declared as global variables. Global variables are defined by omitting the type definition and Groovy's \code{def} keyword. For example \code{myValue = 42} will create a global variable. The \code{@myValue} notation cannot be used. To specify a data type for a global variable, use a constructor (\code{myVar = new Integer(42)}) or a type suffix (\code{myVar = 42L}).

\subsection{Groovy and Java Classes}

If you already know Java, using Java classes in Groovy will be very familiar. Java package members are imported (i.e., made accessible to the script) using the \code{import} statement. Groovy automatically imports many common Java packages by default such as \code{java.io.*}, \code{java.lang.*}, \code{java.net.*}, and \code{java.util.*}. If the package is not part of the JRE, add the package's JAR file to the \code{class.path} parameter of the \code{ScriptEngine\$new} constructor. \strong{Tip:} Supply class paths as separate elements of a vector instead of concatenating the paths with the usual path delimiters (“;” for Windows, and “:” for all others). This will help make your code platform-independent and easier to read.

This example uses the \href{http://commons.apache.org/proper/commons-math/}{Apache Commons Mathematics Library} ///cite? to sample from a bivariate normal distribution.

\begin{verbatim}
library("jsr223")

# Include both the Groovy script engine and the Apache Commons Mathematics 
# libraries in the class path. Specify the paths seperately in a character
# vector.
engine <- ScriptEngine$new(
  engine.name = "groovy",
  class.path = c("../engines/groovy-all.jar", "../commons-math3-3.6.1.jar")
)

# The getClassPath method displays the current class path.
engine$getClassPath()

# Define the means and covariance matrix that will be used to create the
# bivariate normal distribution.
engine$means <- c(0, 2)
engine$covariances <- diag(1, nrow = 2)

# Import the package member and instantiate a new class. For Groovy, excluding
# the type and 'def' keyword will make 'mvn' a global variable.
engine %@% "
  import org.apache.commons.math3.distribution.MultivariateNormalDistribution;
  mvn = new MultivariateNormalDistribution(means, covariances);
"

# Take a sample.
engine$invokeMethod("mvn", "sample")

## [1] 0.3279374 0.8652296

# Take three samples.
replicate(3, engine$invokeMethod("mvn", "sample"))

##           [,1]      [,2]      [,3]
## [1,] 0.9924368 -1.295875 0.2025815
## [2,] 2.5145855  2.128243 1.1666272

engine$terminate()
\end{verbatim}

\subsection{A Groovy web UI for editing R data frames}

///
%Example demonstrates harnessing Java in script. Java is great at simplifying multithreading, and here we have cross-platform GUI and HTML stuffs. Make it clear that this is an involved Java solution.

%doesn't handle empty data frames

%recommend running via command line so it shows up in foreground?

%warn that window comes up in background. see if we can do something about it or recommend it is execued from command line.

%///this example also shows how to use another web-based resource with R through a browser. you don't even have to show the browser. you can use the engine alone.
%
%Good example of implementing a somewhat involved Java solution with the quick-development cycle of a ///. We were able to take Java code examples and implement it in Groovy. It is possible to reproduce this example in any of the other \pkg{jsr223}-supported language.
%Java stuff 
%
%The Java platform includes a browser component called \code{WebView} that is based upon the widely-used open source engine \href{https://webkit.org/}{WebKit}///cite?. \code{WebView} is fully programmable, allowing developers to automate interactions with web content and user input.
%
%The following Groovy example example launches 
%
%///handsontable and dependencies may take a while to load the first time.
%
%\href{http://docs.oracle.com/javafx/2/webview/jfxpub-webview.htm}{Adding HTML Content to JavaFX Applications}

\section{R with JavaScript}

The popularity of JavaScript has overflowed the arena of web development into standalone solutions involving databases, charting, machine learning, and network-enabled utilities, to name just a few. Many of these solutions can be harnessed by R with the help of \pkg{jsr223}. Even browser-based scripts that require a document object model (DOM) can be executed using Java's \code{WebView} browser. ///(See ///“A Groovy web UI for editing R data frames” for \code{WebView} details.) Popular JavaScript solutions can be found at \href{https://www.javascripting.com/}{JavaScripting}, an online database of JavaScript solutions. \href{https://github.com/trending/javascript?since=monthly}{Github} also lists trending solutions for JavaScript, as well as other languages.

\href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Nashorn} is the JavaScript dialect included in Java 8. Nashorn implements ECMAScript 5.1. No download is required to use JavaScript with \pkg{jsr223}. Technical documentation and examples are available at \href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Oracle's Nashorn web site} ///cite?.

\subsection{JavaScript and Java classes}

JavaScript Nashorn provides wide support for Java classes, including the ability to extend classes and implement interfaces. Nashorn provides several methods to reference JavaScript classes. The two most common methods are demonstrated below. This code uses a static class method to sort a vector of integers.

\begin{verbatim}
# The method recommended by Nashorn: create a reference to a Java class using
# the built-in Java.type() method. Conceptually, this is similar to importing
# the class.

engine %~% "
var Arrays = Java.type('java.util.Arrays');
var random = R.eval('sample(5)');
Arrays.sort(random);
random;
"

## [1] 1 2 3 4 5

# An alternative method uses the a fully qualified class name, but it
# requires more overhead per call.

engine %~% "
var random = R.eval('sample(5)');
java.util.Arrays.sort(random);
random;
"

## [1] 1 2 3 4 5
\end{verbatim}

The \code{Java.type()} method is required to create Java primitives as demonstrated in this example:

\begin{verbatim}
# Create a Java integer array with five elements.
var IntegerArrayType = Java.type('int[]');
var myArray = new IntegerArrayType(5); 
\end{verbatim}

We reproduce the bivariate normal example in JavaScript to demonstrate importing an external library and to point out an important limitation in Nashorn regarding \code{invokeMethod}.

\begin{verbatim}
library("jsr223")

# Include the Apache Commons Mathematics library in class.path.
engine <- ScriptEngine$new(
  engine.name = "js",
  class.path = "../commons-math3-3.6.1.jar"
)

# Define the means and covariance matrix that will be used to create the
# bivariate normal distribution.
engine$means <- c(0, 2)
engine$covariances <- diag(1, nrow = 2)

# Import the package member and instantiate a new class.
engine %@% "
var MultivariateNormalDistributionClass = Java.type(
  'org.apache.commons.math3.distribution.MultivariateNormalDistribution'
);
var mvn = new MultivariateNormalDistributionClass(means, covariances);
"

# This line would throw an error. Nashorn JavaScript supports 'invokeMethod' for
# native JavaScript objects, but not for Java objects.
# 
## engine$invokeMethod("mvn", "sample")

# Instead, use script...
engine %~% "mvn.sample();"

## [1] 0.3279374 0.8652296

# ...or wrap the method in a JavaScript function.
engine %@% "function sample() {return mvn.sample();}"
engine$invokeFunction("sample")

## [1] 0.2527757 1.1942332

# Take three samples.
replicate(3, engine$invokeFunction("sample"))

##           [,1]      [,2]      [,3]
## [1,] 0.9924368 -1.295875 0.2025815
## [2,] 2.5145855  2.128243 1.1666272

engine$terminate()
\end{verbatim}

\subsection{Using JavaScript solutions - Voca}

\href{https://vocajs.com/}{Voca} ///cite? is a popular library that simplifies many difficult string manipulation tasks such as word wrapping and diacritic detection (e.g., the “\'{e}” caf\'{e}). Using Voca with \pkg{jsr223} is simply a matter of sourcing a single script file. This sample script loads Voca and demonstrates its functionality.

\begin{verbatim}
# Source the Voca library. This creates a utility object named 'v'.
engine$source("./voca.min.js", discard.return.value = TRUE)

# 'prune' truncates string, without break words, ensuring the given length, including
# a trailing "..."
engine %~% "v.prune('A long string to prune.', 12);"

## [1] "A long..."

# Provide a different suffix to 'prune'.
engine %~% "v.prune('A long string to prune.', 16, ' (more)');"

## [1] "A long (more)"

# Voca supports method chaining.
engine %~% "
v('Voca chaining example')
  .lowerCase()
  .words()
"

## [1] "voca"     "chaining" "example"

# Split graphemes.
engine %~% "v.graphemes('cafe\u0301');"

## [1] "c" "a" "f" "é"

# Word wrapping.
engine %~% "v.wordWrap('A long string to wrap', {width: 10});"

## [1] "A long\nstring to\nwrap"

# Word wrapping with custom delimiters.
engine %~% "
v.wordWrap(
  'A long string to wrap',
  {
    width: 10,
    newLine: '<br/>',
    indent: '__'
  }
);
"

## [1] "__A long<br/>__string to<br/>__wrap"
\end{verbatim}

\section{R with Python}

Like R, the \href{https://www.python.org/}{Python} programming language is used widely in science and analytics. Python has a remarkably broad set of features, yet it is also known for being concise and easy to read. The \href{http://www.jython.org/}{Jython} project has migrated Python to the Java platform. Support for popular native libraries such as NumPy and SciPy are underway in a related project \href{http://www.jyni.org/}{JyNI} (the Jython Native Interface).

\strong{Note:} Leading white space is significant in Python; it is used to delimit code blocks. Avoid syntax errors by left-aligning code in multi-line string snippets as shown in the examples that follow.

\subsection{Python and Java classes}

To create a Java object in Python, simply import the associated package and call the class constructor. The \href{https://wiki.python.org/jython/NewUsersGuide}{Jython User Guide} provides further details for using Java classes. This example generates a random number using the \code{java.util.Random} class.

\begin{verbatim}
# Create an object from the java.util.Random class.
engine %~% "
from java.util import Random
r = Random(10)
"

# Jython supports invoking Java methods.
engine$invokeMethod("r", "nextDouble")

## [1] 0.7304303
\end{verbatim}

Jython's \code{jarray} module is required to create native Java arrays. It has two methods: \code{array(sequence, type)} and \code{zeros(length, type)}. The \code{array} method copies a Python sequence to a Java array of the given type. The \code{zeros} method initializes a Java array of the requested type with zero or \code{null}.

\begin{verbatim}
# Use 'jarray.array' to copy a sequence to a Java array of the requested type.
engine %~% "
from jarray import *
myArray = array([3, 2, 1], 'i')
"
engine$myArray

## [1] 3 2 1

# Alternatively, use zeros to initialize an array with zeros or null. This
# example allocates an array and udpates the values with a loop.
engine %~% "
myArray = zeros(5, 'i')
for i in range(myArray.__len__()):
  myArray[i] = i
"
engine$myArray

## [1] 0 1 2 3 4
\end{verbatim}

\subsection{A simple Python HTTP server}

This code sample creates a basic HTTP server in Python that calls R to produce HTML content. The Python script listed here defines two classes. The \code{MyHandler} class processes HEAD and GET requests for the server. The \code{MyServer} class is used by the R script to start and stop the web server. The Python code is adapted from the \href{https://wiki.python.org/moin/BaseHttpServer}{Python Wiki}.

%///test this code with line-wrapping enabled
\begin{verbatim}
import time
import BaseHTTPServer

# HTTP request handler class
class MyHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    def do_HEAD(s):
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()
    def do_GET(s):
        print time.asctime(), "Received request"
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()
        s.wfile.write("<html><head><title>R/Python HTTP Server</title></head>")
        html = R.eval('getHtmlTable()') # Get HTML table from R.
        s.wfile.write(html)
        s.wfile.write("</body></html>")

class MyServer:
    def __init__(self, host_name, port_number, timeout):
        self.host_name = host_name
        self.port_number = port_number
        server_class = BaseHTTPServer.HTTPServer
        self.httpd = server_class((self.host_name, self.port_number), MyHandler)
        self.httpd.timeout = timeout
        print time.asctime(),
            "Server Starts - %s:%s" % (self.host_name, self.port_number)
    def handle_request(self):
        # This method exists only for demonstration purposes. For a production 
        # scenario, see 'SocketServer.serve_forever()'.
        self.httpd.handle_request()
    def close(self):
        self.httpd.server_close()
        print time.asctime(),
            "Server Stops - %s:%s" % (self.host_name, self.port_number)
\end{verbatim}

The R script sources the Python script above and starts the web server. It also defines \code{getHtmlTable}: a function that generates HTML content for the web server. For demonstration purposes, the R script shuts down the Python web server automatically after 60 seconds. Run the R script and point a web browser to \url{http://127.0.0.1:8080} to see the result.

\begin{verbatim}
library("xtable")
library("jsr223")

server.runtime = 60 # Seconds before the HTTP server shuts down.

# Format the iris data set as an HTML table. This function will be called from
# the Python web server in response to an HTTP GET request.
getHtmlTable <- function() {
  t <- xtable(iris, "Iris Data")
  html <- capture.output(print(t, type = "html", caption.placement = "top"))
  paste0(html, collapse = "\n")
}

# Start the python engine.
engine <- ScriptEngine$new(
  engine.name = "python",
  class.path = "../engines/jython-standalone.jar"
)

# Source the Python script.
engine$source("./python-http-server.py", discard.return.value = TRUE)

runServer <- function() {
  # Automatically shut down server when this function exits.
  on.exit(
    {
      engine$invokeMethod("server", "close")
      engine$terminate()
    }
  )
  
  # Create an instance of Python 'MyServer' class which starts the server at the
  # specified port with the given request timeout in seconds. A timeout would 
  # not be used in a production scenario.
  engine %@% "server = MyServer('localhost', 8080, 2)"
  
  # Handle requests for 'server.runtime' seconds before shutting down. The 
  # 'handle_request' method waits for the timeout specified in the 'MyServer' 
  # constructor before returning to the event loop to allow interruptions. In a
  # production scenario, the R side would not be involved in monitoring 
  # requests. See Python's 'SocketServer.serve_forever()' for more information.
  started <- as.numeric(Sys.time())
  while(as.numeric(Sys.time()) - started < server.runtime)
    engine$invokeMethod("server", "handle_request")
}

runServer()
\end{verbatim}

\section{R with Ruby}

The \href{https://www.ruby-lang.org}{Ruby} programming language is a general-purpose, object-oriented programming language invented by Yukihiro Matsumoto. According to Matsumoto, he designed the language to “help every programmer in the world to be productive, and to enjoy programming, and to be happy” ///cite. \href{http://jruby.org/}{JRuby} is a Java implementation of the Ruby language. JRuby is compatible with the popular web application framework \href{http://rubyonrails.org/}{Ruby on Rails}.

%///https://www.youtube.com/watch?v=oEkJvvGEtB4

\strong{Note:} Global variables in Ruby script must be prefixed with a dollar sign. Hence, if we create a variable \code{myValue} using a \pkg{jsr223} assignment (e.g., \code{engine\$myValue <-\, 10}), it is accessed in Ruby script as \code{\$myValue}. Do not use the dollar sign prefix when accessing global variables via \pkg{jsr223} methods (e.g., \code{engine\$get("myValue")}).

\strong{Note:} We have observed a bug in JRuby's exception handling: when JRuby encounters an error, the engine may continue to throw errors erroneously in subsequent evaluation requests. If this happens, restart the script engine.

\subsection{Ruby and Java classes}

JRuby implements several methods to access Java classes in Ruby syntax. For a comprehensive guide, see \href{https://github.com/jruby/jruby/wiki/CallingJavaFromJRuby}{Calling Java from JRuby}. We demonstrate the most intuitive syntax using the multivariate normal random sampler.

\begin{verbatim}
library("jsr223")

# Include both the JRuby script engine and the Apache Commons Mathematics
# libraries in the class path. Specify the paths seperately in a character
# vector.
engine <- ScriptEngine$new(
  engine.name = "ruby", 
  class.path = c(
    "../engines/jruby-complete.jar",
    "../commons-math3-3.6.1.jar"
  )
)

# Define the means and covariance matrix that will be used to create the 
# bivariate normal distribution.
engine$means <- c(0, 2)
engine$covariances <- diag(1, nrow = 2)

# Import the class and create a new object from the class.
engine %@% "
java_import org.apache.commons.math3.distribution.MultivariateNormalDistribution
$mvn = MultivariateNormalDistribution.new($means, $covariances)
"

# This line would throw an error. JRuby supports 'invokeMethod' for
# native Ruby objects, but not for Java objects.
# 
## engine$invokeMethod("mvn", "sample")

# Instead, use script...
engine %~% "$mvn.sample()"

## [1] 0.3279374 0.8652296

# ...or wrap the method in a function.
engine %@% "
def sample()
  return $mvn.sample()
end
"
engine$invokeFunction("sample")

## [1] 0.2527757 1.1942332

# Take three samples.
replicate(3, engine$invokeFunction("sample"))

##           [,1]      [,2]      [,3]
## [1,] 0.9924368 -1.295875 0.2025815
## [2,] 2.5145855  2.128243 1.1666272

engine$terminate()
\end{verbatim}

\hypertarget{usingrubygems}{\subsection{Using Ruby gems}}

Ruby libraries and programs are distributed in a standardized package format called a \textit{gem}. We demonstrate using gems in \pkg{jsr223} with Ty Rauber's \href{https://github.com/tyrauber/stock_quote}{\code{stock\_quote}} gem ///cite?. 

A full installation of JRuby is required to use gems. Install JRuby and the \code{stock\_quote} gem using the instructions found in \href{https://github.com/jruby/jruby/wiki/GettingStarted}{Getting Started with JRuby}.%///cite? 

To access \code{stock\_quote} with \pkg{jsr223}, the paths to the gem and its dependencies must be added to the \code{ScriptEngine\$new} class path. These paths can be discovered using the JRuby REPL, \code{jirb}, as shown here.

\begin{verbatim}
me@ubuntu:~$ jirb
irb(main):001:0> require 'stock_quote'
=> true
irb(main):002:0> puts $LOAD_PATH
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/unf-0.1.4-java/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/domain_name-0.5.20160826/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/http-cookie-1.0.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/mime-types-2.99.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/netrc-0.11.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/rest-client-1.8.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/stock_quote-1.2.3/lib
~/jruby-9.1.5.0/lib/ruby/2.3/site_ruby
~/jruby-9.1.5.0/lib/ruby/stdlib
=> nil
irb(main):003:0> exit
\end{verbatim}

Supply the resulting paths to the \code{class.path} parameter of the \pkg{jsr223} \code{ScriptEngine\$new} method. In our experience, the \samp{site\_ruby} path did not exist. If \code{ScriptEngine\$new} throws an error indicating a path does not exist, simply exclude it from the class path.

The code sample below downloads closing price history for two stocks and displays them in a combined time series plot (Figure \ref{fig:stocks}). The R packages \CRANpkg{jsonlite} ///cite and \CRANpkg{ggplot2} ///cite are required. %///Maybe do without jsonlite///

\begin{figure}[h]
\centering
\includegraphics[width=1\linewidth]{graphics/stocks}
\caption{Plot of closing stock prices produced by data obtained using Ty Rauber's \code{stock\_quote} Ruby gem.}
\label{fig:stocks}
\end{figure}

\begin{verbatim}
library("jsr223")
library("jsonlite")
library("ggplot2")

# In addition to the script engine JAR, include all of the required gem paths in
# the class path. In this case, we use 'jruby.jar' from the full installation 
# instead of the standalone script engine JAR file.
# 
# The gem paths were obtained by running the JRuby REPL 'jirb' in the terminal
# and executing the following two commands:
# 
# require 'stock_quote'
# puts $LOAD_PATH

class.path <- "
~/jruby-9.1.5.0/lib/jruby.jar
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/unf-0.1.4-java/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/domain_name-0.5.20160826/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/http-cookie-1.0.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/mime-types-2.99.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/netrc-0.11.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/rest-client-1.8.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/stock_quote-1.2.3/lib
~/jruby-9.1.5.0/lib/ruby/stdlib
"
class.path <- unlist(strsplit(class.path, "\n", fixed = TRUE))

engine <- ScriptEngine$new(
  engine.name = "jruby",
  class.path = class.path
)

# Import the required Ruby libraries.
engine %@% "
require 'date'
require 'stock_quote'
"

# Print some real-time stock data to the console.
engine %@% "
$stock = StockQuote::Stock.quote('AEPGX')
puts $stock.name, $stock.change
"

# Ruby function to retrieve a year of closing stock prices for a given symbol in
# JSON format.
engine %@% "
def getStockYear(symbol)
  end_date = Date.today
  start_date = end_date.prev_year
  h = StockQuote::Stock.history(
    symbol,
    start_date = start_date,
    end_date = end_date,
    select = 'Close, Date',
    format = 'json'
  )
  return JSON.generate(h.fetch('quote'))
end
"

# R function wrapper to convert the Ruby JSON result to a data frame.
getStockYear <- function(symbol) {
  json <- engine$invokeFunction("getStockYear", symbol)
  df <- jsonlite::fromJSON(json)
  df$Close <- as.numeric(df$Close)
  df$Date <- as.POSIXct(df$Date)
  df
}

# Get closing values as data frames for two stocks.
aepgx <- getStockYear("AEPGX")
agthx <- getStockYear("AGTHX")

# Graph the closing values via 'ggplot2'.
ggplot() +
  geom_line(data = aepgx, aes(x = Date, y = Close, color = "AEPGX")) +
  geom_line(data = agthx, aes(x = Date, y = Close, color = "AGTHX")) +
  ggtitle("Closing Stock Prices: AEPGX, AGTHX") +
  theme(legend.position = c(0.1, 0.9), legend.title = element_blank()) +
  labs(x = "Date", y = "Closing Price")

engine$terminate()
\end{verbatim}

\hypertarget{softwarereview}{\section{Software review}}

There are several programming language integrations that combine the strengths of R with other development environments. These language integrations can generally be classified as either R-major or R-minor. R-major integrations use R as the primary environment to control some other embedded language environment. R-minor integrations are the inverse of R-major integrations. The built-in R integrations for C/C++ are examples of both integration types. The base R functions .C and .Call are R-major integrations that enable C/C++ compiled code to be called from R. The complementary R-minor integration permits C/C++ applications to call R as a shared library when R is built using the -{}-enable-R-shlib configuration option.

\pkg{jsr223} is an R-major integration for the Java platform and the scripting languages JavaScript, Python, Ruby, and Groovy. In this software review, we provide context for the \pkg{jsr223} project through comparisons with other R-major integrations. Popular R-minor language integrations such as \CRANpkg{Rserve} ///cite and \CRANpkg{OpenCPU} ///cite are not included in this discussion because their objectives and features do not necessarily align with those of \pkg{jsr223}.

Before beginning the individual package comparisons, we point out the one unique feature that contrasts \pkg{jsr223} with all other integrations in this discussion. \pkg{jsr223} is the only package that provides a standard interface to integrate R with multiple languages. This key feature enables developers to take advantage of solutions and features in several languages without the need to learn or install new packages.

\subsection{\pkg{rJava}}

The preeminent Java integration for R is Simon Urbanek's \pkg{rJava}. Described as a low-level R to Java interface, \pkg{rJava} is considered the Java analog to the base R functions .C and .Call. \pkg{rJava} supports creating objects, calling methods and accessing Java object fields via JNI, the Java Native Interface. JNI is a standardized programming interface that enables native (i.e. platform-specific) applications to embed the Java Virtual Machine (JVM) and use compiled Java classes.

\pkg{jsr223} uses \pkg{rJava}'s low-level interface together with the Java Scripting API to provide high-level access to the Java platform through several scripting languages. In a sense, \pkg{jsr223} builds on \pkg{rJava}, extending several features, and adding many new ones///don't say this, you aren't in \pkg{rJava} anymore///. We provide a basic comparison of \pkg{rJava} and \pkg{jsr223} features.

///better development loop/time. no compile. immediate feedback. it's what we like about R. so we like it about \pkg{jsr223}.

\noindent \textit{Data interchange}

\noindent \pkg{rJava} supports the interchange of scalars, vectors, matrices, and arrays between R and the Java environment. In addition to these data structures, \pkg{jsr223} supports exchanging lists, nested lists, and data frames. \pkg{jsr223} includes several configurable data options. For example, R data frames can be converted to row-major or column-major data structures in the Java environment and R factors can be passed as either strings or integers.

Passing data structures between environments with \pkg{rJava} requires knowledge of JNI, Java types, and \pkg{rJava}'s programming interface. In \pkg{jsr223}, data interchange is reduced to simple R-like variable operations. To create or update a variable named \code{value} in the embedded scripting environment, simply use \code{engine\$value <-  object} where \code{engine} is a \pkg{jsr223} reference to a script engine. To retrieve the value, use \code{engine\$value}. This intuitive interface substantially reduces the learning curve and coding effort required to exchange data.

\pkg{jsr223}'s data handling capabilities are encapsulated in two functions. The function \code{convertToJava} coerces R objects to generic Java objects, and \code{convertToR} does the inverse. \pkg{jsr223} exports these functions to extend the data handling capabilities of \pkg{rJava} independently of \pkg{jsr223}'s scripting language interface. These functions enable solutions that already implement \pkg{rJava} to add support for lists and data frames with very minimal code.

\noindent \textit{Code execution and using Java objects}

\noindent \pkg{rJava} provides access to compiled Java code through the JNI. Consequently, a programmer must learn the basics of the JNI to use Java objects. 

The JNI is not like 

, \pkg{jsr223} provides access to compiled Java code. 

\pkg{jsr223} also supports execution of non-compiled code on the Java platform via several scripting languages. 

. This feature  of but it is implemented through it allows access to also allows Java objects to be used naturally in scripting languages in object-oriented.

In addition to the low-level JNI interface, \pkg{rJava} provides an experimental convenience operator, \code{\$}, that allows high-level access to Java methods. This impressive feat is accomplished by inspecting the Java object's interface on the fly. The cost of this convenience is performance, as each call incurs significant overhead. However, it does provide more natural language access to Java objects in R code. As noted on the \pkg{rJava} web site, the high-level interface may not always work as expected for complex scenarios, and it may change in future versions.

Consequently, a programmer must learn the basics of the JNI to use \pkg{rJava}'s low-level interface.

Where \pkg{rJava} provides access to compiled Java code via JNI and function calls, \pkg{jsr223} provides access
///language vs. whatever///. ///javatoR

\pkg{jsr223} can be used with \pkg{rJava} indendent of scripting languages. See the convertToJava and convertToR functions.

\pkg{rJava} does not support executing uncompiled code from R. \pkg{jsr223} great for prototypeing/don't have to compile.

\pkg{rJava} creates Java objects using the \code{.jnew} function and JNI syntax and methods are accessed using the \code{.jcall} function as demonstrated earlier. When invoking methods, it is often necessary to declare the explicit data types for return values and arguments.

In \pkg{jsr223}, Java objects can be created and manipulated in natural syntax within a scripting language. For example, in Groovy, Java objects are manipulated using Java language syntax. Because \pkg{jsr223}-supported scripting languages are dynamically typed, knowledge of specific data types for method return values and arguments is usually not required. The following code example demonstrates ///something/// in both Groovy script and \pkg{rJava}'s low-level interface.

\pkg{jsr223} also supports calling Java methods directly from R using the \code{invokeMethod} function, similar to \pkg{rJava}'s \code{.jcall}, when the object is created via Groovy or Jython. In contrast to \pkg{rJava}, the parameter data types and return values do not need to be explicitly stated, and complex data structures such as lists and data frames are supported as parameters and return values.

\pkg{jsr223}-supported scripting languages support advanced object-oriented paradigms such as subclassing and interface implementation. ///Say something else relevant here.///

///Something about the high-level interface.

Console mode shortens development cycle, quick feedback to code changes and shorter learning curve.

\noindent \textit{Calling R}

\noindent \pkg{rJava} does not directly support callbacks into R. It includes  Instead, it includes a separate R-minor integration package 

supports callbacks into R through a companion package \CRANpkg{JRI}: the Java/R Interface. To use \pkg{JRI}, R must be compiled with the shared library option -{}-enable-R-shlib. \pkg{JRI} also requires several paths and environment variables to be set, so it includes a launch script to get started. \pkg{JRI} is an R-minor integration; generally projects that implement \pkg{JRI} are not  Generally, projects implementing \pkg{JRI} are  \pkg{JRI} provides both high and low-level access to R features through a large collection of Java packages.

\pkg{jsr223} supports callbacks into R using a lightweight interface that provides just three methods to execute R code, set values, and retrieve values. \pkg{jsr223} implements callbacks using multi-threading and synchronization, not \pkg{JRI}. Therefore, \pkg{jsr223} does not require R to be compiled as a shared library. ///continue with conclusion of comparison and mention recursive callbacks and error handling.///

\noindent \textit{Performance Comparison}

\noindent ///Maybe...///

In conclusion, \pkg{jsr223} adds to \pkg{rJava}'s excellent Java integration for R through a simplified interface that is easy to learn and use. \pkg{jsr223} allows integration code to be written and tested on the Java platform without compiling, enables Java objects to be created and used in natural-language syntax, and streamlines data interchange. In all, these features substantially lower the barrier for developing effective Java integrations for R.

\section{\pkg{jsr223} package design}

///
%Mention a little bit about supporting generic interfaces for data instead of custom R classes.

\section{\pkg{jsr223} API}

///

\section{Data interchange}
%///review these notes, but remove this section

///
%Mention a little bit about supporting generic interfaces for data instead of custom R classes.
%Generic Collections and Maps are supported, giving us almost everything. There are some specific conversions for ///Ruby, for example///. Speicifics for collections.

%Talk about the problems of converting collections, and where collections are used. For example, JavaScript's arrays are actually collections. These must be detected. Integers must be separated from arrays.

%///
%Collection interface covers many typical data structures in serveral different languages including ArrayList, etc.

\section{Limitations and known issues}

///

% \strong{Note:} The Groovy and Python engines support using \code{engine\$invokeMethod()} to call methods of Java objects. JavaScript and Ruby do not.

%///\pkg{jsr223} is not strictly threadsafe.

%///callbacks must be on the original thread. is this true? it might not be. if there is a limitation, note it here and in callbacks.

%///classpaths remain loaded after closing an engine. This is \pkg{rJava}. Restart R.
%///if something complains “Failed to instantiate engine 'python'. Make sure the engine dependencies are in the class path.”, restart R. It is a class path issue.

%///\section{Package version history}

%///\section{Document version history}

\section{Conclusion}

%///people can use tools they know. Java is very accessible.
///

\clearpage

\bibliography{gilbert-dahl}

\address{Floid R. Gilbert\\
    Department of Statistics\\
    Brigham Young University\\
    Provo, UT 84602\\
    USA\\}
\email{floid.r.gilbert@gmail.com}

\address{David B. Dahl\\
    Department of Statistics\\
    Brigham Young University\\
    Provo, UT 84602\\
    USA\\}
\email{dahl@stat.byu.edu}

