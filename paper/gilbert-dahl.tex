% !TeX root = RJwrapper.tex
\title{\pkg{jsr223}: A Simple Interface Between R, Java, and Java-Based Scripting Languages Groovy, JavaScript, JRuby (Ruby), Jython (Python), Kotlin, and Scala}
\author{by Floid R. Gilbert and David B. Dahl}

%///update code sample original files. Made a lot of changes in-line.
%///use the language for state found here instead of using ``environment'': http://openjdk.java.net/jeps/222
%///update links to Oracle to openJDK instead.
%///https://discuss.kotlinlang.org/t/how-can-i-use-scripts-in-kotlin-1-1-m02-eap/2064/3
%///can use other languages in the future, if they decide to do \pkg{jsr223} support
%///In addition to creating and using Java objects in script, classes can be extended and interfaces can be implemented. 
\maketitle

\abstract{
The R package \pkg{jsr223} is a high-level integration for the Java platform that makes Java objects easy to use from within R, provides a unified interface to integrate R with several Java-based programming languages, features extensive data exchange capabilities between R and Java, and allows R code to be executed from within the supported programming languages using a simple callback interface. This integration leverages the performance benefits and cross-platform capabilities of the Java platform and expands the computing capabilities of the R software environment.

%The R package \pkg{jsr223} is a high-level integration for Java that makes Java objects easy to use from within R and simplifies bi-directional data exchange for a variety of data structures. Furthermore, \pkg{jsr223} employs the Java Scripting API to bring four scripting languages and, by extension, countless libraries to the R software environment. \pkg{jsr223} uses intuitive syntax to blend JavaScript, Ruby, Python, and Groovy (a Java-like scripting language) with R script. In all, this integration leverages the performance benefits and cross-platform capabilities of the Java Virtual Machine and extends the computing capabilities of the R software environment.
}

\section{Introduction}

%About the same time Ross Ihaka and Robert Gentleman began developing R at the University of Auckland in the early 1990s, James Gosling and the so-called Green project team was working on a new programming language at Sun Microsystems in California. The Green team didn't set out to make a new language; rather, they were trying to move platform-independent, distributed computing into the consumer electronics marketplace. As Gosling explained, ``All along, the language was a tool, not the end.'' The Green project was short-lived. However, the resulting programming language, Java, flourished into one of the most popular development platforms in computing history. %Today, the Java computing environment is deployed in environments ranging from enterprise servers to mobile phones.

About the same time Ross Ihaka and Robert Gentleman began developing R at the University of Auckland in the early 1990s, James Gosling and the so-called Green project team was working on a new programming language at Sun Microsystems in California. The Green team didn't set out to make a new language; rather, they were trying to move platform-independent, distributed computing into the consumer electronics marketplace. As Gosling explained, ``All along, the language was a tool, not the end.'' Unexpectedly, the programming language outlived the Green project and flourished into one of the most popular development platforms in computing history. That platform, Java, now powers applications ranging from the enterprise (GMail), to games (Minecraft), to interactive media (Blue-ray), to mobile devices (Android).

In 2003, Simon Urbanek released \pkg{rJava}, an integration package designed to avail R of the burgeoning development surrounding Java. The package has been very successful to this end, and it continues as one of the top-ranked solutions for R as measured by monthly downloads.\footnote{The \pkg{rJava} package ranks in the $95^{\text{th}}$ percentile for R package downloads according to \href{http://rdocumentation.org}{http://rdocumentation.org}.} \pkg{rJava} is described by Urbanek as a low-level R to Java interface analogous to .C and .Call, the built-in R methods for calling compiled C code. Like R's integration for C, \pkg{rJava} loads compiled code into an R process's memory space where it can be accessed via various R methods. Urbanek achieves this feat using the Java Native Interface (JNI), a standard framework that enables native (i.e. platform-dependent) code to access and use compiled Java code. The \pkg{rJava} API requires users to specify classes and data types in JNI syntax. One advantage to this approach is that the user has granular, direct access to Java classes. However, as with any low-level interface, the learning curve is relatively high and implementation can be code-intensive. Another advantage of using JNI is that it avoids the overhead and complexity of dynamically interpreting or compiling source code. Of course, this is also a disadvantage: it limits \pkg{rJava} to compiled code as opposed to embedding dynamic source code directly within R script.

Our \pkg{jsr223} package builds on \pkg{rJava} to provide a high-level, extended R interface to the Java platform. In addition, \pkg{jsr223} serves as a simple, unified integration interface between R and several Java-based programming languages. To date, \pkg{jsr223} supports six languages: Groovy, JavaScript, JRuby, Jython, Kotlin, and Scala. (JRuby and Jython are Java implementations of the Ruby and Python languages, respectively.) Each of these languages support creating and using Java objects in their own syntax. Source code for any of these languages can be embedded directly within R script, promoting rapid application development. The \pkg{jsr223} package provides this functionality using the Java Scripting API \citep{jsa} as defined by the specification “JSR-223: Scripting for the Java Platform” \citep{jsr223spec}. The \pkg{jsr223} package also provides an intuitive callback API to access R from any of the supported languages. Finally, \pkg{jsr223} significantly simplifies and extends data exchange capabilities between R and Java. In all, \pkg{jsr223} lowers the barrier to the performance benefits and cross-platform capabilities of the Java platform and expands the computing capabilities of the R software environment.

The following code example is taken from \pkg{rJava}'s \href{http://www.rforge.net/rJava/}{web site}. It demonstrates \code{.jnew()} and \code{.jcall()}: the essential functions of the \pkg{rJava} API. Java objects are used to create a window with a single button, display it, and close it. \strong{Note:} The window may not display in the foreground on your system and the last line in the code is required to close the window.

\begin{verbatim}
library("rJava")
.jinit()
f <- .jnew("java/awt/Frame", "Hello")
b <- .jnew("java/awt/Button", "OK")
.jcall(f, "Ljava/awt/Component;", "add", .jcast(b, "java/awt/Component"))
.jcall(f, , "pack")
# Show the window.
.jcall(f, , "setVisible", TRUE)
# Close the window.
.jcall(f, , "dispose")
\end{verbatim}
This JavaScript snippet reproduces the \pkg{rJava} example. In comparison to the \pkg{rJava} example, the JavaScript code is more natural for most programmers to write and maintain. This same example can be reproduced in any of the five other \pkg{jsr223}-supported programming languages.

\begin{verbatim}
var f = new java.awt.Frame('Hello');
f.add(new java.awt.Button('OK'));
f.pack();
// Show the window.
f.setVisible(true);
// Close the window.
f.dispose();
\end{verbatim}
Using \pkg{jsr223}, the preceding code snippet can be embedded in an R script. The first step is to create an instance of a script engine. A JavaScript engine is created thus:

\begin{verbatim}
library(jsr223)
engine <- ScriptEngine$new("JavaScript")
\end{verbatim}
This engine is now ready to evaluate script on demand. Script can be passed to the engine using character vectors or file paths. The sample below demonstrates embedding JavaScript code in-line with character vectors. This method is appropriate for small snippets of so-called glue code. 

\begin{verbatim}
# Execute code inline to show the window.
engine %@% "
var f = new java.awt.Frame('Hello');
f.add(new java.awt.Button('OK'));
f.pack();
f.setVisible(true);
"

# Close the window
engine %@% "f.dispose();"
\end{verbatim}
Alternatively, code can be sourced from a file using the script engine object's \code{source} method: \code{engine\$source(file.name)}. The variable \code{file.name} may specify a local path or a URL. This approach is recommended for more lengthy scripts.

The \pkg{rJava} package supports exchanging scalars, arrays, and matrices between R and Java. The following R code demonstrates copying an R matrix to a Java object, and converting it back to an R object using \pkg{rJava}.

\begin{verbatim}
a <- matrix(rnorm(10), 5, 2)

# Copy matrix to a Java object with rJava
o <- rJava::.jarray(a, dispatch = TRUE)
# Convert it back to an R matrix.
b <- rJava::.jevalArray(o, simplify = TRUE)
\end{verbatim}
The same operation is achieved in \pkg{jsr223} using the following code, where \code{engine} is an instance of a \pkg{jsr223} ScriptEngine object. Essentially, \pkg{jsr223} reduces complex data exchange operations to list-like operations.

\begin{verbatim}
# Copy matrix to a Java object using jsr223.
engine$a <- a
# Retrieve the matrix.
engine$a
\end{verbatim}
The \pkg{jsr223} package supports converting R vectors, factors, n-dimensional arrays, data frames, lists, and environments to generic Java objects.\footnote{\pkg{rJava}'s interface can potentially support n-dimensional arrays, but as of this writing the feature does not produce correct results for n > 2.} The \pkg{jsr223} package also supports converting Java scalars, n-dimensional arrays, maps, and collections to R objects. Row-major and column-major ordering schemes are available for both data frames and n-dimensional arrays. Some language integration packages offer a similar feature set using JSON serialization. Our package uses custom serialization routines to avoid the round-off error and overhead associated with JSON conversion.

A more detailed discussion of how \pkg{jsr223} compares to \pkg{rJava} and other relevant packages is included in \hyperlink{softwarereview}{Software review}. ///Necessary? Or is the project justified at this point?///

There are three primary use cases for \pkg{jsr223}. Most importantly, any of the \pkg{jsr223}-supported languages can be used to quickly and efficiently embed Java solutions in R. The relative learning curve associated with such implementations is relatively low. Second, \pkg{jsr223} provides access to solutions developed in any of the \pkg{jsr223}-supported languages. For example, Ruby gems can be used from within R. Lastly, the callback interface included with \pkg{jsr223} can be used to embed R within any of the supported languages. This feature does not require linking to R as a shared library, nor does it employ client-server architecture. As explained in the quick start guide///maybe link///, the callback feature can only be used in scripts, not pre-compiled code.

\subsection{Document organization}

We define some needed terminology, and then we put the \pkg{jsr223} project in context with a review of relevant software. Next, there are the necessary installation instructions and a quick start guide to detail the major features. The most interesting sections follow with code samples that blend R with the \pkg{jsr223}-supported languages. All code samples related to this document are available at \href{http://notavalidaddresss////}{GitHub}.

\section{Helpful terminology and concepts}

Java programs are compiled to Java bytecode that is executed by an instance of a Java Virtual Machine (JVM). The JVM is an abstraction layer that provides a platform-independent execution environment for Java programs. The JVM interprets Java bytecode to machine code (i.e., processor-specific instructions). JVMs are available for a wide variety of hardware and software platforms. In principle, the same Java program will run on any platform that supports a JVM. The Java paradigm contrasts with traditional compiled languages, such as C, that are compiled directly to processor-dependent machine code, and therefore must be recompiled for every targeted architecture. Often, changes in the source code are also required to support different platforms.

Today, there are several programming languages that compile down to Java bytecode including all of the languages currently supported by \pkg{jsr223}. This may be surprising to some readers because languages like JavaScript are traditionally interpreted only, not compiled. In fact, the \pkg{jsr223}-supported languages blur the line between scripting languages (those that are interpret-only), and traditional compiled languages. Nevertheless, we generally refer to the languages supported by \pkg{jsr223} as scripting languages in this document because source code can be interpreted and executed (i.e., evaluated) in one step. Even so, this implementation benefits from the significant performance gains of compiled code.

A \dfn{scripting engine} (usually shortened to \dfn{script engine}) is software that enables a scripting language to be embedded in an application. Internally, a script engine uses an \dfn{interpreter} to parse and execute source code. The terms \dfn{script engine} and \dfn{interpreter} are often used interchangeably. In this document, \dfn{script engine} refers to the software component, not the interpreter. A \dfn{script engine instance} denotes an instantiated script engine. Finally, a \dfn{script engine environment} refers to the state (i.e., the variables and settings) of a given instance.

\dfn{Bindings} refers to the name/value pairs associated with variables in a given scope. Conceptually, a variable's name is bound to its value. The variable names and values in R's global environment are examples of bindings.

\hypertarget{softwarereview}{\section{Software review}}

There are many programming language integrations that combine the strengths of R with other development environments. These language integrations can generally be classified as either \dfn{R-major} or \dfn{R-minor}. R-major integrations use R as the primary environment to control some other embedded language environment. R-minor integrations are the inverse of R-major integrations. The base R distribution features both integration types for C and C++. The functions .C and .Call are R-major integrations that enable C/C++ compiled code to be called from R. The R-minor integration permits C/C++ applications to call R as a shared library when R is built using the \samp{-{}-enable-R-shlib} configuration option.

The \pkg{jsr223} package provides an R-major integration for the Java platform and the \pkg{jsr223}-supported programming languages. In this software review, we provide context for the \pkg{jsr223} project through comparisons with other R-major integrations. Popular R-minor language integrations such as \CRANpkg{Rserve} ///cite and \CRANpkg{OpenCPU} ///cite are not included in this discussion because their objectives and features do not necessarily align with those of \pkg{jsr223}.

Before beginning the individual package comparisons, we point out one unique feature that contrasts \pkg{jsr223} with all other integrations in this discussion: \pkg{jsr223} is the only package that provides a standard interface to integrate R with multiple languages. This key feature enables developers to take advantage of solutions and features in several languages without the need to learn or install new packages.

\subsection{\pkg{rJava}}

The primary Java integration for R is Simon Urbanek's \pkg{rJava}. Described as a low-level R to Java interface, \pkg{rJava} is the Java analog to the base R functions .C and .Call. \pkg{rJava} supports creating objects, calling methods and accessing Java object fields via JNI, the Java Native Interface. JNI is a standardized programming interface that enables native (i.e. platform-specific) applications to embed the Java Virtual Machine (JVM) and use compiled Java classes.

The \pkg{jsr223} package uses \pkg{rJava}'s low-level interface together with the Java Scripting API to provide high-level access to the Java platform through several scripting languages. In essence, \pkg{jsr223} builds on \pkg{rJava} in four ways: it makes Java objects easier to use; it allows Java classes to be implemented and extended in script; it simplifies and extends data exchange; and finally, it facilitates callbacks without additional setup or expertise. These points are demonstrated in the following examples.

This code example is taken from \pkg{rJava}'s \href{http://www.rforge.net/rJava/}{web site}. It creates a window with a single button, displays it, and closes it. \strong{Note:} The window may not display in the foreground on your system and the last line in the code is required to close the window.

\begin{verbatim}
library("rJava")
.jinit()
f <- .jnew("java/awt/Frame", "Hello")
b <- .jnew("java/awt/Button", "OK")
.jcall(f, "Ljava/awt/Component;", "add", .jcast(b, "java/awt/Component"))
.jcall(f, , "pack")
# Show the window.
.jcall(f, , "setVisible", TRUE)

# Close the window.
.jcall(f, , "dispose")
\end{verbatim}

The \pkg{rJava} function \code{.jnew} creates objects from Java classes. The \code{.jcall} function invokes methods of the classes. Both of these functions return R S4 objects that wrap the resulting Java object in memory.

 of the \code{java.awt.Frame} class. 
The main low-level differences: useability, data exchange, callbacks.




\pkg{rJava} creates Java objects using the \code{.jnew} function and JNI syntax and methods are accessed using the \code{.jcall} function as demonstrated earlier. When invoking methods, it is necessary to know the explicit classes for return values and arguments.

\begin{verbatim}
library("jsr223")
engine <- ScriptEngine$new("js")
engine %@% "
var f = new java.awt.Frame('Hello');
f.add(new java.awt.Button('OK'));
f.pack();
# Show the window.
f.setVisible(true);
"

# Close the window.
engine %@% "f.dispose();"
\end{verbatim}

\begin{verbatim}
var f = new java.awt.Frame('Hello');
f.add(new java.awt.Button('OK'));
f.pack();
f.setVisible(true);
f.dispose();
\end{verbatim}



As mentioned previously, the \pkg{rJava} low-level interface requires knowledge of JNI. In many cases, it is necessary to know the explicit data types for method return values and parameters.
.jcall
.jew




0. \pkg{rJava} is best at using existing classes.
1. JNI vs. scripting -- lower learning curve and perhaps quicker feedback loop.
X. Can actually extend and use classes and implement classes in-line.
2. Data exchange
3. Callbacks


///better development loop/time. no compile. immediate feedback. it's what we like about R. so we like it about \pkg{jsr223}.

\noindent \textit{Data exchange}

\noindent \pkg{rJava} supports data interchange for scalars, vectors, and matrices between R and the Java environment. As of this writing, \pkg{rJava} support for n- In addition to these data structures, \pkg{jsr223} supports exchanging lists, nested lists, and data frames. \pkg{jsr223} includes several configurable data options. For example, R data frames can be converted to row-major or column-major data structures in the Java environment and R factors can be passed as either strings or integers.

Passing data structures between environments with \pkg{rJava} requires knowledge of JNI, Java types, and \pkg{rJava}'s programming interface. In \pkg{jsr223}, data interchange is reduced to simple R-like variable operations. To create or update a variable named \code{value} in the embedded scripting environment, simply use \code{engine\$value <- object} where \code{engine} is a \pkg{jsr223} reference to a script engine. To retrieve the value, use \code{engine\$value}. This intuitive interface substantially reduces the learning curve and coding effort required to exchange data.

\noindent \textit{Code execution and using Java objects}

\noindent \pkg{rJava} provides access to compiled Java code through the JNI. Consequently, a programmer must learn the basics of the JNI to use Java objects. 

In addition to the low-level JNI interface, \pkg{rJava} provides an experimental convenience operator, \code{\$}, that allows high-level access to Java methods. This impressive feat is accomplished by inspecting the Java object's interface on the fly. The cost of this convenience is performance, as each call incurs significant overhead. However, it does provide more natural language access to Java objects in R code. As noted on the \pkg{rJava} web site, the high-level interface may not always work as expected for complex scenarios, and it may change in future versions.


In \pkg{jsr223}, Java objects can be created and manipulated in natural syntax within a scripting language. For example, in Groovy, Java objects are manipulated using Java language syntax. Because \pkg{jsr223}-supported scripting languages are dynamically typed, knowledge of specific data types for method return values and arguments is usually not required. The following code example demonstrates ///something/// in both Groovy script and \pkg{rJava}'s low-level interface.

\pkg{jsr223} also supports calling Java methods directly from R using the \code{invokeMethod} function, similar to \pkg{rJava}'s \code{.jcall}, when the object is created via Groovy or Jython. In contrast to \pkg{rJava}, the parameter data types and return values do not need to be explicitly stated, and complex data structures such as lists and data frames are supported as parameters and return values.

Console mode shortens development cycle, quick feedback to code changes and shorter learning curve.

\pkg{rJava}'s high-level interface ties into autocompletion. 

\noindent \textit{Calling R}

\noindent \pkg{rJava} does not directly support callbacks into R. It includes  Instead, it includes a separate R-minor integration package JRI.

supports callbacks into R through a companion package \CRANpkg{JRI}: the Java/R Interface. To use \pkg{JRI}, R must be compiled with the shared library option -{}-enable-R-shlib. \pkg{JRI} also requires several paths and environment variables to be set, so it includes a launch script to get started. \pkg{JRI} is an R-minor integration; generally projects that implement \pkg{JRI} are not  Generally, projects implementing \pkg{JRI} are  \pkg{JRI} provides both high and low-level access to R features through a large collection of Java packages.

\pkg{jsr223} supports callbacks into R using a lightweight interface that provides just three methods to execute R code, set values, and retrieve values. \pkg{jsr223} implements callbacks using multi-threading and synchronization, not \pkg{JRI}. Therefore, \pkg{jsr223} does not require R to be compiled as a shared library. ///continue with conclusion of comparison and mention recursive callbacks and error handling.///

\noindent \textit{Performance Comparison}

\noindent ///Maybe...///

In conclusion, \pkg{jsr223} adds to \pkg{rJava}'s excellent Java integration for R through a simplified interface that is easy to learn and use. \pkg{jsr223} allows integration code to be written and tested on the Java platform without compiling, enables Java objects to be created and used in natural-language syntax, and streamlines data interchange. In all, these features substantially lower the barrier for developing effective Java integrations for R.

\section{not a sectino. just stuff}

The \pkg{jsr223} package takes its name from the 

///maybe use JSR-223 spec to methods.
We use the Java Scripting API defined by the specification “JSR-223: Scripting for the Java Platform” \citep{jsr223spec} to enable users to create and use Java objects using any one of several programming languages from within R. Additionally, \pkg{jsr223} serves as a unified integration interface for the supported programming languages, allowing R users to easily blend R with other solutions and language features. Finally, \pkg{jsr223} simplifies and extends data exchange between R and Java, and it provides an intuitive callback API to access R from Java. In all, this integration leverages the performance benefits and cross-platform capabilities of the Java Virtual Machine and extends the computing capabilities of the R software environment.


As other languages adopt the JSR-223 specification, \pkg{jsr223} will work with those also.

Maybe a feature list.

Also note what it can be used for. What are the applications? Separate that from the features so it is easier to read.

In 2006, ///remove name/// Sun Microsystems released the Java Scripting API \citep{jsa} defined by the specification “JSR-223: Scripting for the Java Platform” \citep{jsr223spec}. The JSR-223 specification includes two crucial elements: an interface for Java applications to execute code written in scripting languages, and a guide for scripting languages to create Java objects in their own syntax. Several scripting language projects have adopted JSR-223. Some of the most successful projects to date include JavaScript \citep{jsnashorn}, Jython \citep{jython}, JRuby \citep{jruby}, and Groovy \citep{groovy}. Jython and JRuby are Java implementations of the Python \citep{python} and Ruby \citep{ruby} languages, respectively. Groovy is a scripting implementation of the Java programming language. The Java platform has benefited a great deal from the addition of these scripting languages. Solutions developed in Python, for example, are now accessible to applications on the Java Virtual Machine (JVM). In essence, JSR-223 has facilitated the creation of a larger development ecosystem on the Java platform.

Just as JSR-223 extends the Java platform, our \CRANpkg{jsr223} package extends the R development environment. \pkg{jsr223} uses the Java Scripting API to enable solutions written in JavaScript, Python, Ruby, and Groovy to be embedded within R. \pkg{jsr223} also provides simplified access to Java classes through any of these languages by merit of the JSR-223 specification, substantially lowering the barrier for programmers that want to use Java classes in R. In all, \pkg{jsr223} makes countless existing solutions immediately available to R developers and promotes the rapid development of new R solutions that can exploit the Java platform.

While there are other R packages that provide integrations for Java, JavaScript, Python, Ruby, and Groovy, \pkg{jsr223} offers a unique combination of features that make it particularly compelling to statistical developers. The primary features of \pkg{jsr223} are listed here.

\begin{enumerate}
\item Java classes are easy to instantiate, implement, and extend directly in script. As such, \pkg{jsr223} provides high-level access to the cross-platform and performance benefits of the Java platform.

\item \pkg{jsr223} exposes a user-friendly programming interface that is consistent across multiple scripting languages. This enables developers to leverage solutions in several languages with a single R package.

\item \pkg{jsr223} reduces complex data exchange operations between R and Java to a simple variable assignment. Data exchange in \pkg{jsr223} is fast and precise (no rounding). \pkg{jsr223} supports the primary data structures in both R and Java. For R, the supported structures are vectors, factors, n-dimensional arrays, data frames, lists, and environments. For Java, scalars, n-dimensional arrays, maps, and collections are supported. Row-major and column-major ordering schemes are available for data frames and n-dimensional arrays.

\item \pkg{jsr223} includes a callback interface.
\end{enumerate}

 First and foremost, \pkg{jsr223} offers high-level access to the cross-platform and performance benefits of the Java platform. Second, Java classes can be instantiated, implemented, and extended in script. Third, \pkg{jsr223} exposes a user-friendly programming interface that is consistent across multiple scripting languages. This enables developers to leverage solutions in several languages with a single R package. Third, \pkg{jsr223} reduces complex data exchange operations between R and Java to a simple variable assignment. Data exchange in \pkg{jsr223} is fast and precise (no rounding). \pkg{jsr223} supports the primary data structures in both R and Java. For R, the supported structures are vectors, factors, n-dimensional arrays, data frames, lists, and environments. For Java, scalars, n-dimensional arrays, maps, and collections are supported. Both row-major and column-major ordering are available for data frames and n-dimensional arrays. While existing R packages provide some of these features, none provide all of these features together. We believe that \pkg{jsr223} can significantly extend the computing capabilities of the R software environment with a relatively low learning curve. A detailed discussion of how \pkg{jsr223} compares to other packages is included in \hyperlink{softwarereview}{Software review}.



\pkg{jsr223} supports extensive data interchange between R, Java and the supported scripting environments. \pkg{jsr223} also features direct calls to scripted functions and methods, script compiling, and a callback interface that provides embedded scripts access to the R environment. Finally, \pkg{jsr223} is easy to install and can be used with any standard R installation.


\pkg{jsr223} is built on \CRANpkg{rJava} \citep{rjava}, the low-level R to Java interface. The design of \pkg{jsr223} follows cues from \pkg{rJava}, \CRANpkg{rscala} \citep{rscala}, and \CRANpkg{V8} \citep{v8pkg}.



p-i
free
oop
scalable
secure
stable
was backwards-compat

Lots of packages have built on \pkg{rJava}.

In 2006, Java Scripting API. Unique. Makes it simple to embed languages generically. Moreover, lets languages use Java objects in their own syntax. For example, a JavaScript /// can be used to ///.

We build on \pkg{rJava} and the Java Scripting API to bring ///. These are the resulting features.

\pkg{jsr223} takes it's name from the JSR-223 specification that...

Other packages use Java Scripting API. They have these shortcomings/strengths.


The J is very popular, surging again in popularity this year with the release of J8 (TIOBE). Some of the features contributing to Java's success are p-i, free, scalability, security, stability, backwards-compatibility, object-oriented, garbage collection. With adoption, community. A lot of freely developed stuff out there. Other languages. Except, I can't. Oh wait, yes I can because they are Java objects...I think. Wait, can they?

From its inception in 1991 (///cite http://oracle.com.edgesuite.net/timeline/java/  see reference to the book), the Java computing environment was designed to be platform-independent: a Java program could be compiled once and run on a variety of hardware and operating systems without modification. Certainly, the ``write once, run anywhere'' paradigm is one is one of the most important factors behind Java's success. The popularity of Java has produced a /// developer community that has produced a /// amount of software that is either open source or free to use. This, along with Java's free-to-use ///, it has With its tremendous developer community and 

However, with popularity comes innovation and ///.
with success, the reasons to use Java has grown significantly beyond just platform-independence. Java development platform is a mature has become a secure, stable language with With success, a /// ecosystem of developers, tools, and libraries This success has  But, with success, a tremendous ecosystem of  the Java platform has  the main reason that Java is that has made Java one of the most popular platforms today. This popularity has produced a lot of libraries and innovation, scalability, etc. and the language is easy to learn.

This means a programmer can develop code on a PC and can expect it to run on Java enabled cell phones, as well as on routers and mainframes equipped with Java, without any adjustments. This is intended to save software developers the effort of writing a different version of their software for each platform or operating system they intend to deploy on.

%///Discuss popularity/significance of Java.
%///Mention that JSR223 was made part of JRE (use their jargon)
%///the uses of this package: use features of other languages, use libraries from other languages, use scripting languages as glue for Java libraries and for access to the JVM.
%///consider big int or big decimal calulations in statistical context
%///review all syntax. I've changed some things including names of arguments. I've updated some code examples.
%///http://www.theserverside.com/feature/Top-7-takeaways-about-the-Java-platform-from-JavaOne-2015
Java continues to be one of the most popular development platforms. Lots of development, great community.
Free to use.
Continually developed.

Platform independent - runs on computers, phones, etc.
It maintains good performance --- as good as native code, sometimes better (reference) due to dynamic code analysis (what is that?)
It has been around a while (over 20 years), and so it is stable.  Zara states that the code you may have written 15 years ago will run on the latest JVMs and gain the speed advantage of the latest profiling, native code translating, and memory management. https://www.pearsonfrank.com/blog/why-is-java-so-popular-developers
lots of very good tools and ecosystem
free to use
https://www.azul.com/4-reasons-java-still-1/
Java is an all-round universal programming language. Due to its solidity and scalability, Java can be found on mobiles, desktops and large-scale industry servers and applications.


The JCP uses Java Specification Requests to specify any additions or changes to the platform.

In 2006, ///remove name/// Sun Microsystems released the Java Scripting API \citep{jsa} defined by the specification “JSR-223: Scripting for the Java Platform” \citep{jsr223spec}. The JSR-223 specification includes two crucial elements: an interface for Java applications to execute code written in scripting languages, and a guide for scripting languages to create Java objects in their own syntax. Several scripting language projects have adopted JSR-223. Some of the most successful projects to date include JavaScript \citep{jsnashorn}, Jython \citep{jython}, JRuby \citep{jruby}, and Groovy \citep{groovy}. Jython and JRuby are Java implementations of the Python \citep{python} and Ruby \citep{ruby} languages, respectively. Groovy is a scripting implementation of the Java programming language. The Java platform has benefited a great deal from the addition of these scripting languages. Solutions developed in Python, for example, are now accessible to applications on the Java Virtual Machine (JVM). In essence, JSR-223 has facilitated the creation of a larger development ecosystem on the Java platform.

Just as JSR-223 extends the Java platform, our \CRANpkg{jsr223} package extends the R development environment. \pkg{jsr223} uses the Java Scripting API to enable solutions written in JavaScript, Python, Ruby, and Groovy to be embedded within R. \pkg{jsr223} also provides simplified access to Java classes through any of these languages by merit of the JSR-223 specification, substantially lowering the barrier for programmers that want to use Java classes in R. In all, \pkg{jsr223} makes countless existing solutions immediately available to R developers and promotes the rapid development of new R solutions that can exploit the Java platform.

While there are other R packages that provide integrations for Java, JavaScript, Python, Ruby, and Groovy, \pkg{jsr223} offers a unique combination of features that make it particularly compelling to statistical developers. The primary features of \pkg{jsr223} are listed here.

\begin{enumerate}
\item Java classes are easy to instantiate, implement, and extend directly in script. As such, \pkg{jsr223} provides high-level access to the cross-platform and performance benefits of the Java platform.

\item \pkg{jsr223} exposes a user-friendly programming interface that is consistent across multiple scripting languages. This enables developers to leverage solutions in several languages with a single R package.

\item \pkg{jsr223} reduces complex data exchange operations between R and Java to a simple variable assignment. Data exchange in \pkg{jsr223} is fast and precise (no rounding). \pkg{jsr223} supports the primary data structures in both R and Java. For R, the supported structures are vectors, factors, n-dimensional arrays, data frames, lists, and environments. For Java, scalars, n-dimensional arrays, maps, and collections are supported. Row-major and column-major ordering schemes are available for data frames and n-dimensional arrays.

\item \pkg{jsr223} includes a 
\end{enumerate}

 First and foremost, \pkg{jsr223} offers high-level access to the cross-platform and performance benefits of the Java platform. Second, Java classes can be instantiated, implemented, and extended in script. Third, \pkg{jsr223} exposes a user-friendly programming interface that is consistent across multiple scripting languages. This enables developers to leverage solutions in several languages with a single R package. Third, \pkg{jsr223} reduces complex data exchange operations between R and Java to a simple variable assignment. Data exchange in \pkg{jsr223} is fast and precise (no rounding). \pkg{jsr223} supports the primary data structures in both R and Java. For R, the supported structures are vectors, factors, n-dimensional arrays, data frames, lists, and environments. For Java, scalars, n-dimensional arrays, maps, and collections are supported. Both row-major and column-major ordering are available for data frames and n-dimensional arrays. While existing R packages provide some of these features, none provide all of these features together. We believe that \pkg{jsr223} can significantly extend the computing capabilities of the R software environment with a relatively low learning curve. A detailed discussion of how \pkg{jsr223} compares to other packages is included in \hyperlink{softwarereview}{Software review}.


\pkg{jsr223} supports extensive data interchange between R, Java and the supported scripting environments. \pkg{jsr223} also features direct calls to scripted functions and methods, script compiling, and a callback interface that provides embedded scripts access to the R environment. Finally, \pkg{jsr223} is easy to install and can be used with any standard R installation.


\pkg{jsr223} is built on \CRANpkg{rJava} \citep{rjava}, the low-level R to Java interface. The design of \pkg{jsr223} follows cues from \pkg{rJava}, \CRANpkg{rscala} \citep{rscala}, and \CRANpkg{V8} \citep{v8pkg}.

\section{Package installation}

The \pkg{jsr223} package requires Java 8 Standard Edition or above. The current version of the Java Runtime Environment (JRE) can be determined by executing \samp{java -version} from a system command prompt. See the example output below. Java 8 is denoted by version 1.8.x\_xx.

\begin{verbatim}
java version "1.8.0_91"
Java(TM) SE Runtime Environment (build 1.8.0_91-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b15, mixed mode)
\end{verbatim}

The JRE can be obtained from  \href{http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html}{Oracle's web site}. Select the architecture (32 or 64 bit) that matches your R installation.

\pkg{jsr223} runs on a standard installation of R (e.g., the R build option \code{--enable-R-shlib} is not required). \pkg{jsr223} is available on CRAN and can be installed with the usual command:

\begin{verbatim}
install.packages("jsr223")
\end{verbatim}

\hypertarget{scriptengineinstallation}{\section{Script engine installation}}

To create an instance of a language's script engine, \pkg{jsr223} requires access to the associated script engine libraries. These instructions will help you obtain these libraries in the form of a standalone Java Archive (JAR) file. Though it is possible to use a full language installation with \pkg{jsr223} instead of a standalone file, those instructions are not included here for the sake of simplicity and portability.

\subsection{Groovy}

\href{http://groovy-lang.org}{Groovy} is a Java-like language enhanced with modern dynamic programming features. Java code can often be executed by the Groovy engine with little modification. In essence, our integration with Groovy brings the Java language to R.

To obtain the standalone Groovy engine, go to \url{http://groovy-lang.org} and click the \samp{Download} link. Locate the current binary distribution. Download and extract the archive to a temporary folder. Locate the \samp{embeddable} subfolder. Copy the file named \samp{groovy-all-x.x.x.jar} to a convenient location and make note of the path. This path will be used by \pkg{jsr223} to load the script engine.

\subsection{JavaScript (Nashorn)}

\href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Nashorn} is the JavaScript dialect included in Java 8. Nashorn implements ECMAScript 5.1. No download is required to use JavaScript with \pkg{jsr223}. Technical documentation and examples for Nashorn are available at \href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Oracle's web site}.

\subsection{JRuby}

\href{http://jruby.org}{JRuby} is a Java-based implementation of the Ruby programming language. Obtain the standalone JRuby engine by clicking the \samp{Downloads} link at at \url{http://jruby.org}. Find \samp{JRuby x.x.x.x Complete.jar} and save it to a convenient location. Make note of the path; it will be used by \pkg{jsr223} to load the script engine.

\subsection{Jython}

\href{http://www.jython.org}{Jython} is a Java-based implementation of the Python programming language. The standalone Jython engine is available at \url{http://www.jython.org}. Follow the \samp{Download} link. Click \samp{Download Jython x.x.x - Standalone Jar} to start the download. Save the JAR file to a convenient location and remember the path. This path will be used by \pkg{jsr223} to load the script engine.

\section{Quick start guide}

The primary features of \pkg{jsr223} are designed to be accessible to R programmers of all experience levels. This quick start guide illustrates these features with simple code examples. Unless otherwise stated, code samples in this section should work for all of the supported scripting languages with one exception: global objects in Ruby script must be prefixed with a dollar sign.

\subsection{Hello world}

This R code snippet demonstrates the basic elements required to embed a scripting language: start a script engine, optionally pass data to the script engine environment, execute a script, and terminate the script engine when it is no longer needed.

%///replace all verbatim with example or whatever it is that R Journal uses.
\begin{verbatim}
library("jsr223")
engine <- ScriptEngine$new("javascript")
engine$message <- "Hello world"
engine %~% "print(message);"

## Hello world

engine$terminate()
\end{verbatim}

The \code{ScriptEngine\$new} constructor method creates a script engine instance. In the preceding example, we assign the new script engine object to the variable \code{engine}. The first argument of \code{ScriptEngine\$new} specifies the type of script engine to create. In this case, we create a JavaScript engine. The third line assigns the value \code{"Hello world"} to a global variable named \code{message} in the script engine environment. The next line executes a JavaScript code snippet using the \code{\%$\sim$\%} operator. The snippet uses the JavaScript \code{print} method to write the message to the console. The last line in the example terminates the script engine and releases the associated resources.

To create a script engine other than JavaScript, specify a different script engine name and a path to the required script engine JAR file. (See \hyperlink{scriptengineinstallation}{Script engine installation} for instructions to obtain a script engine JAR file.) The supported script engine names are listed in Table \ref{tab:script-engine-type-names}. These names are defined by the script engine provider. \strong{Note:} Script engine names are case sensitive.

The next example reproduces the “Hello world” example in Ruby script.

\begin{verbatim}
library("jsr223")
engine <- ScriptEngine$new(
  engine.name = "ruby",
  class.path = "../engines/jruby-complete.jar"
)
engine$message <- "Hello world"
engine %~% "puts $message"

## Hello world

engine$terminate()
\end{verbatim}

In this case, two parameters are passed to the \code{ScriptEngine\$new} method: the script engine name \code{"ruby"}, and the path to the JRuby script engine JAR file. As before, we assign the value \code{"Hello world"} to a global variable named \code{message} and print it to the console. Notice that we prefix the global variable with a dollar sign: \code{\$message}. This syntax is peculiar to global variables in the Ruby language.

\begin{table}[h]
    \small
    \centering
    \begin{tabular}{l p{8cm}}
        \toprule
        \textbf{Language} & \textbf{Script engine names} \\
        \midrule
        \noalign{\vspace{1ex}}
        \href{http://groovy-lang.org}{Groovy} &  \code{groovy}, \code{Groovy}\\[.25cm]
        \href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{JavaScript (Nashorn)} & \code{js}, \code{JS}, \code{JavaScript}, \code{javascript}, {nashorn}, \code{Nashorn}, \code{ECMAScript}, \code{ecmascript}\\[.25cm]
        \href{http://jruby.org}{JRuby (Ruby)} & \code{jruby}, \code{ruby}\\[.25cm]
        \href{http://www.jython.org}{Jython (Python)} & \code{jython}, \code{python}\\[.25cm]
        \noalign{\vspace{1ex}}
        \bottomrule
    \end{tabular}
    \caption{The \code{ScriptEngine\$new} constructor method creates a new script engine instance for a given language using the names in this table. The names are case sensitive.}
    \label{tab:script-engine-type-names}
\end{table}

\subsection{Executing script}

\pkg{jsr223} provides several methods to execute script. The lines

\begin{verbatim}
return.value <- engine %~% script
return.value <- engine$eval(script)
\end{verbatim}

\noindent both evaluate the expression in the character vector \code{script}. The return value is the result of the last expression in the script, if any, or \code{NULL} otherwise. Text written to standard output by the script engine is printed to the R console. The following line executes JavaScript code and assigns the result to an R variable.

\begin{verbatim}
result <- engine %~% "isFinite(1);"
\end{verbatim}

The following lines also execute script, but there are no return values. This notation is convenient if the last expression in the snippet returns unneeded data or an unsupported type.

\begin{verbatim}
engine %@% script
engine$eval(script, discard.return.value = TRUE)
\end{verbatim}

\noindent To execute a script file, use either of the following lines where \code{file.name} is the path (or URL) to the script file.

\begin{verbatim}
engine$source(file.name)
engine$source(file.name, discard.return.value = TRUE)
\end{verbatim}

The methods \code{eval} and \code{source} take an argument named \code{bindings} that accepts an R named list. The name/value pairs in the list replace the script engine's global bindings during script execution. The following example demonstrates this functionality. Notice that the result of \code{a + b} changes when bindings are specified.

\begin{verbatim}
engine$a <- 2
engine$b <- 3
engine$eval("a + b")

## 5

lst1 <- list(a = 6, b = 7)
engine$eval("a + b", bindings = lst1)

## 13

lst2 <- list(a = 6)
# This line would throw an error because 'b' is no longer defined.
## engine$eval("a + b", bindings = lst2)

# When 'bindings' is not specified, the script engine reverts to the default
# global bindings.
engine$eval("a + b")

## 5
\end{verbatim}

\subsection{Sharing data between language environments}

The following two lines of R code are equivalent: they convert an R object to a Java object and assign the new object to a global variable named \code{"myValue"} in the script engine's environment. This syntax is the same for all supported R data structures.

\begin{verbatim}
engine$myValue <- iris
engine$set("myValue", iris)
\end{verbatim}

To retrieve \code{myValue} from the script engine (i.e., to convert a Java object to an R object), use either of the following lines.

\begin{verbatim}
engine$myValue
engine$get("myValue")
\end{verbatim}

Remove the \code{myValue} variable with \code{engine\$remove("myValue")}. List all global variables in the script engine's environment with \code{engine\$getBindings()}.

All data structures in Java-based scripting languages are backed by Java objects. Discover the Java class for any global variable using  \code{engine\$getJavaClassName("identifier")} where \code{identifier} is the variable's name.

Behind the scenes, \pkg{jsr223}'s simplified data exchange is provided by \CRANpkg{jdx}: Java Data Exchange for R and \pkg{rJava}. The \pkg{jdx} package's functionality was originally part of \pkg{jsr223}, but it was broken out into a separate package to simplify maintenance and to make its features available to other developers.

The \pkg{jdx} package (and hence \pkg{jsr223}) supports converting R vectors, factors, n-dimensional arrays (such as matrices), data frames, named lists, unnamed lists, nested lists (i.e., lists containing lists), and environments to generic Java objects. Row-major and column-major ordering options are available for both arrays and data frames. R data types numeric, integer, character, raw, and logical are supported. Complex types and date/time classes are not supported: convert them to character vectors.

Java scalars, n-dimensional arrays, collections, and maps can be converted to standard objects in the R environment. The supported Java structures cover all of the primary types used in the supported scripting languages. Moreover, collections and maps are ubiquitous in Java APIs; providing support for these structures gives R developers easy access to a vast number of data structures available on the Java platform.

All of the \pkg{jdx} data conversion options are mirrored by settings in \pkg{jsr223}. The most pertinent details are discussed in the following sections including \hyperlink{dataexchangedetails}{Data exchange details}. For a more thorough, low-level discussion, see the vignette included with the \pkg{jdx} package. 

\subsection{Setting and getting script engine options}

The \pkg{jsr223} \code{ScriptEngine} class exposes several methods that control settings for a script engine instance. These methods are named using the Java getter/setter convention: methods that set values are prefixed with ``set'' and methods that retrieve values begin with ``get''. For example, if \code{engine} is a script engine object, \code{engine\$setArrayOrder('column-major')} will change the \textit{array order} setting. The code \code{engine\$getArrayOrder()} will retrieve the current \textit{array order} setting.

\hypertarget{handlingrvectors}{\subsection{Handling R vectors}}

By default, length-one R vectors are converted to Java scalars when passed to the script engine environment. If a Java length-one array is desired, wrap the value in the R ``as-is'' function (e.g., \code{I(myValue)}), or set the \textit{length one vector as array} setting to \code{TRUE} using the \code{setLengthOneVectorAsArray} method. The following example demonstrates converting length-one vectors.

\begin{verbatim}
# By default, length-one vectors are converted to Java scalars.
engine$setLengthOneVectorAsArray(FALSE)
engine$myScalar <- 1
engine$getJavaClassName("myScalar")

## [1] "java.lang.Double"

# Wrap the vector in I() to indicate that an array should be created instead.
# The resulting Java class name is "[D" which denotes a primitive, double 
# one-dimensional array.
engine$myArray <- I(1)
engine$getJavaClassName("myArray")

## [1] "[D"

# To change the conversion behavior for all length-one vectors, set the 
# 'length one vector as array' setting to TRUE.
engine$setLengthOneVectorAsArray(TRUE)
engine$myArray <- 1
engine$getJavaClassName("myArray")

## [1] "[D"
\end{verbatim}

Vectors of any length other than one are always converted to primitive Java arrays. The following code passes a vector of ten random normal deviates to the script engine environment. The first element of the resulting array is returned. This syntax is common to all of the supported scripting languages. \strong{Note:} Java arrays use zero-based indexes.

\begin{verbatim}
set.seed(10)
engine$norms <- rnorm(10)
engine %~% "norms[0]"

## [1] 0.01874617
\end{verbatim}

\subsection{Handling R matrices and other n-dimensional arrays}

By default, n-dimensional arrays are copied in row-major order. The following example demonstrates converting a simple 2 x 2 R matrix. Because the order is row-major, the last line of code returns the element in the first row, second column. Remember, Java arrays use zero-based indexes.

\begin{verbatim}
m <- matrix(1:4, 2, 2)
m

##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4

engine$m <- m
engine %~% "m[0][1]"

## [1] 3
\end{verbatim}

%///update this based on what is changed in jdx.
%///furthermore, I might have the names all wrong. the data structures are correct, but the names might be wrong.
The \code{setArrayOrder} script engine method controls index ordering for arrays converted from R to Java, and vice versa. Three array index ordering schemes are available: \code{'row-major'}, \code{'column-major'}, and \code{'row-major-java'}. Before describing these schemes, it is helpful to think of n-dimensional arrays as collections of smaller structures. A one-dimensional array (a vector) is a collection of scalars. A two-dimensional array (a matrix) is a collection of one-dimensional arrays representing either rows or columns of a matrix. A three-dimensional array (a rectangular prism or cube) is a collection of matrices. A four-dimensional array is a collection of cubes, and so forth. Java n-dimensional arrays are literally constructed in this fashion. R n-dimensional arrays, on the other hand, are stored in memory as a vector and the data is retrieved in the appropriate order using indexing arithmetic.

Now we describe the each of the array indexing options.

\begin{itemize}
\item \strong{row-major} -- The indexes of an n-dimensional array are ordered \newline\code{[row][column][matrix]...[n]}. The \pkg{jsr223} package defaults to 'row-major' because R uses this scheme. However, this scheme is not intuitive for Java programmers when n > 2 because Java n-dimensional arrays are constructed as higher-order objects containing lower-order objects.

\item \strong{column-major} -- The indexes of an n-dimensional array are ordered \newline\code{[n]...[matrix][column][row]}. This ordering scheme is natural for Java programmers because this is the order that Java arrays are literally constructed. The data contained at the one-dimensional level represent columns of the parent matrix.

\item \strong{row-major-java} -- The indexes of an n-dimensional array are ordered \newline\code{[n]...[matrix][row][column]}. This is similar to the \code{'column-major'} ordering scheme except that the arrays at the one-dimensional level represent rows of the parent matrix. For matrices, 'row-major-java' and 'row-major' are equivalent.

\end{itemize}

\strong{Note:} Always use the same array ordering scheme when transferring the same array data back and forth between R and Java. For example, if an R array is converted to Java using column-major ordering, and then converted back from Java to R using row-major ordering, the R array will be in the wrong order.

In the following JavaScript example, a three-dimensional array is copied to the script engine using each of the three indexing options. In each case, the Java static method \code{deepToString} creates a string representation of the array to show the resulting order of the data in the script engine.

\begin{verbatim}
a <- array(1:8, c(2, 2, 2))
a

## , , 1
## 
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    5    7
## [2,]    6    8

engine$setArrayOrder("row-major")
engine$a <- a
engine %~% "java.util.Arrays.deepToString(a);"

## [1] "[[[1, 5], [3, 7]], [[2, 6], [4, 8]]]"

engine$setArrayOrder("column-major")
engine$a <- a
engine %~% "java.util.Arrays.deepToString(a);"

## [1] "[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"

engine$setArrayOrder("row-major-java")
engine$a <- a
engine %~% "java.util.Arrays.deepToString(a);"

## [1] "[[[1, 3], [2, 4]], [[5, 7], [6, 8]]]"
\end{verbatim}

\hypertarget{handlingrdataframes}{\subsection{Handling R data frames}}

R data frames can be converted to the script engine using either row-major or column-major order. Row-major order (the default) creates a list of records. This representation is perhaps the most common in programming for tabular data. Column-major order, on the other hand, creates a list of columns. Column-major structures are faster to create and are generally preferred for aggregate column calculations. Change the \textit{data frame order} setting with the \code{setDataFrameRowMajor} method.

When the row-major setting is selected (i.e., \code{engine\$setDataFrameRowMajor(TRUE)}), an R data frame is converted to a \href{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html}{\code{java.util.ArrayList}} object. The list contains  \href{https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html}{\code{java.util.LinkedHashMap}} objects that represent the rows of the data frame. Each member of the hash map is a name/value pair of a single field in the data frame. The name of the field is the corresponding column's name. The following example uses R's built-in \code{iris} data set to illustrate using row-major data frames in the script environment. This syntax is the same for all scripting languages. (Remember to prefix the global variables with \code{\$} in Ruby).

\begin{verbatim}
engine$setDataFrameRowMajor(TRUE)
engine$iris <- iris

# Return the number of rows.
engine %~% "iris.size()"

## [1] 150

# Retrieve the sepal length in the first row.
engine %~% "iris[0].get('Sepal.Length')"

## [1] 5.1

# Retrieve the second row as a list.
engine %~% "iris[1]"

## $`Sepal.Length`
## [1] 4.9
## 
## $Sepal.Width
## [1] 3
## 
## $Petal.Length
## [1] 1.4
## 
## $Petal.Width
## [1] 0.2
## 
## $Species
## [1] "setosa"
\end{verbatim}

When the column-major setting is selected (i.e., \code{engine\$setDataFrameRowMajor(FALSE)}), an R data frame is converted to a \href{https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html}{\code{java.util.LinkedHashMap}} object. The map members are arrays representing the columns in the data frame. The following commented example uses R's built-in \code{mtcars} data set to illustrate basic functionality. This syntax is supported for all scripting languages.

\begin{verbatim}
engine$setDataFrameRowMajor(FALSE)

# 'mtcars' is an R data frame containing information for 32 cars. 'mtcars'
# stores vehicle names as row names. Row names are not preserved during
# conversion. This line creates a new R data frame with the vehicle names as
# a new column 'name'.
df <- data.frame(name = row.names(mtcars), mtcars)

# This line converts the new data frame to a Java map named 'mtcars'.
engine$mtcars <- df

# Return the number of columns in the map.
engine %~% "mtcars.size()"

## [1] 12

# Access each column using the map's 'get' method and the column's name. This
# line returns the first element of the column 'name'.
engine %~% "mtcars.get('name')[0]"

## [1] "Mazda RX4"

# Add a new column named 'cylsize' representing the size of a single cylinder.
engine$cylsize <- mtcars[, "disp"] / mtcars[, "cyl"]
engine %@% "mtcars.put('cylsize', cylsize)"

# Remove the columns 'name' and 'cylsize'.
engine %@% "mtcars.remove('name')"
engine %@% "mtcars.remove('cylsize')"

# Compare the contents of the map to the original data frame in R.
all.equal(mtcars, engine$mtcars, check.attributes = FALSE)

## [1] TRUE
\end{verbatim}

Groovy and JavaScript support an additional syntax that allows map elements to be accessed like object properties instead of using the \code{get} and \code{put} methods.

\begin{verbatim}
# The following two lines are equivalent in Groovy and JavaScript.
engine %~% "mtcars.cyl[0];"
engine %~% "mtcars.get('cyl')[0];"
\end{verbatim}

\subsection{Handling R factors}

R factors are comprised of a character vector of levels and an integer vector of indexes that reference the levels. For example, if the integer vector \code{5:7} is converted to a factor, the levels will be \code{c("5", "6", "7")} and the indexes will be \code{c(1L, 2L, 3L)}. The script engine \textit{coerce factors} setting determines how the factor levels are handled when converting the factor to a Java array. When this setting is enabled (e.g., \code{engine\$setCoerceFactors(TRUE)}), an attempt is made to coerce the factor levels to integer, numeric, or logical values. If coercion fails, the character levels are used. When \textit{coerce factors} is disabled, the factor is always converted to a string array. The \textit{coerce factors} setting applies to standalone factors as well as factors in data frames.

After \pkg{jsr223} converts an R factor to a Java array, there is no consistent way to determine whether the array was originally created from an R factor. Therefore, if an R factor is copied to the script engine, and then the resulting array is returned to R, it will be converted to an R vector, not a factor.

When creating a data frame in R, character vectors are converted to factors by default. The \pkg{jsr223} package follows this standard when a qualifying Java object is converted to an R data frame. The \code{setStringsAsFactors} method modifies this behavior. The method takes one of three values: \code{NULL}, \code{TRUE}, and \code{FALSE}. If \code{NULL} is specified (the default), the R system setting is used (see \newline\code{getOption("stringsAsFactors")}). A value of \code{TRUE} ensures that character vectors are always converted to factors for new data frames. Finally, a setting of \code{FALSE} disables conversion to factors.

\subsection{Handling R lists and environments}
The \pkg{jsr223} package converts R lists and environments to Java objects. List elements may be any R data structure supported by \pkg{jsr223}, including other lists (i.e., nested lists). There is no limitation to the levels of nesting.

R named lists and environments are converted to Java \href{https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html}{\code{java.util.HashMap}} objects. See \hyperlink{handlingrdataframes}{Handling R data frames} for map code examples. The only difference is that a data frame's contents are always converted to a map of arrays. For lists, the map elements may be any data structure.

R unnamed lists are converted to Java objects implementing the \href{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html}{\code{java.util.ArrayList}} interface. The following code demonstrates basic \code{java.util.ArrayList} functionality.

\begin{verbatim}
# Create an unnamed list with three elements.
engine$list <- list(c("a", "b", "c"), TRUE, pi)

# Members in the list are accessed by index. This line returns the first element.
engine %~% "list[0]"

## [1] "a" "b" "c"

# Replace an element in the list.
engine %@% "list[0] = 'replaced'"

# Add a new element to the end of the list.
engine %@% "list.add('last item')"

# Insert a new item before the first item.
engine %@% "list.add(0, 'first item')"

# Remove the last item.
engine %@% "list.remove(list.size() - 1)"

# Return the number of elements
engine %~% "list.size()"

## [1] 4
\end{verbatim}

\subsection{Data exchange details}

So far, we have discussed all of the basic functionality and settings related to data exchange. This section includes a few additional notes for data exchange. For a comprehensive guide, including potentially unexpected conversion behaviors, see the \pkg{jdx} package vignette.

R reserves special \code{NA} values to indicate missing types. Table \ref{tab:r-na-behavior} outlines how \code{NA} values are handled for different R data types. Table \ref{tab:java-null-behavior}, in turn, describes how Java null values are interpreted when converting Java objects to R.

\begin{table}[b]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
R Structure      & NA Behavior                                         \\ \midrule
\code{numeric}   & \code{NA\_real\_} maps to a reserved value.           \\[.25cm]
\code{integer}   & \code{NA\_integer\_ maps} to a reserved value.        \\[.25cm]
\code{character} & \code{NA\_character\_} maps to Java \code{null}.      \\[.25cm]
\code{logical}   & \code{NA} maps to Java \code{false} with a warning. \\ \bottomrule
\end{tabular}
\caption{R reserves special \code{NA} values to indicate missing types. This table outlines how \code{NA} values are converted to Java values.}
\label{tab:r-na-behavior}
\end{table}

Because \pkg{jsr223} converts data to generic Java data structures, R attributes such as names cannot always be included in conversion. For example, R vectors are converted to native Java arrays, therefore names associated with vector elements must be discarded. Likewise, dimension names are not preserved for n-dimensional structures. Column names for data frames are preserved, but row names are not. To preserve data frame row names, simply copy the names to a new column before converting the data frame.

The \pkg{jsr223} package always converts R vectors and arrays to Java arrays. Java arrays are intuitive to use in all of the supported scripting environments. However, the supported scripting languages can also create array structures that are not native Java arrays. \pkg{jsr223} also supports converting these language-specific array and collection structures to R vectors and arrays.

Java n-dimensional arrays whose subarrays of a given dimension are not the same dimension are known as \dfn{ragged arrays}. Ragged arrays cannot be converted to R arrays. Instead, \pkg{jsr223} translates ragged arrays to lists of the appropriate object. For example, a matrix containing subarrays of different lengths will be converted to an R list of vectors. Likewise, a three-dimensional array containing two matrices of different dimensions will be converted to an R list of matrices.

As described earlier, R unnamed lists are converted to \href{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html}{\code{java.util.ArrayList}} objects. The \code{ArrayList} class implements the \href{https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html}{\code{java.util.Collection}} interface. This is one of the most basic interfaces in Java and it is common to a large number of structures. \pkg{jsr223} converts Java objects implementing the \code{java.util.Collection} interface to vectors, n-dimensional arrays, data frames, and unnamed lists, depending on the structure's content. In some cases an R list converted to a Java object, and then converted back to an R object, may not produce an R list. See the sections ``Java Collections'' and ``Conversion Issues'' in the \pkg{jdx} package vignette for conversion rules and in-depth explanations.

The jdx package converts R raw values to Java byte values and vice versa. R raw values and Java byte values are both 8 bits, but they are interpreted differently. R raw values range from 0 to 255 (i.e., unsigned bytes). Java byte values range from -128 to 127 (i.e., signed bytes). The 8-bit value 0xff represents 255 in R, but is -1 in Java. Usually this discrepancy is not an issue because raw and byte values are used to store and transfer binary data such as images. If human-readable values are important, use integer vectors instead.

\begin{table}[t]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Java Structure                             & Java null Behavior                                             \\ \midrule
\code{Boolean[]..[]} & \code{null} maps to \code{FALSE} with a warning.           \\[.25cm]
\code{Byte[]..[]}       & \code{null} maps to \code{raw} \code{0x00} with a warning. \\[.25cm]
\code{Character[]..[]}  & \code{null} maps to \code{NA\_character\_}.                \\[.25cm]
\code{Double[]..[]}   & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Float[]..[]}     & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Integer[]..[]}     & \code{null} maps to \code{NA\_integer\_}.                  \\[.25cm]
\code{java.math.BigDecimal[]..[]}          & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{java.math.BigInteger[]..[]}          & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Long[]..[]}       & \code{null} maps to \code{NA\_real\_}.                     \\[.25cm]
\code{Object[]..[]}                        & \code{null} maps to \code{NULL}.                           \\[.25cm]
\code{Short[]..[]}     & \code{null} maps to \code{NA\_integer\_}.                  \\[.25cm]
\code{java.lang.String[]..[]}              & \code{null} maps to \code{NA\_character\_}.                \\ \bottomrule
\end{tabular}
\caption{Java \code{null} indicates missing or uninitialized values. This table outlines how \code{null} is interpreted when converting Java objects to R.}
\label{tab:java-null-behavior}
\end{table}

\subsection{Calling script functions and methods}

Functions and methods defined in script can be called directly from R via the \code{invokeFunction} and \code{invokeMethod} script engine methods. Any number of supported R structures can be passed as parameter values.

\strong{Note:} The Groovy and Python engines can use \code{invokeMethod} to call methods of Java objects. The JavaScript and Ruby engines only support calling methods of native scripting objects.

As described in \hyperlink{handlingrvectors}{Handling R vectors}, length-one vectors are converted to Java scalars by default. One way to ensure that a vector is always converted to a Java array is by wrapping it in the ``as-is'' function \code{I()}. This feature is particularly useful when passing multiple parameters to a script function. In the same function, some parameters may require scalars while others require arrays. Simply use \code{I()} to indicate which vectors should be converted to arrays.

The following example demonstrates calling a simple JavaScript function, \code{sumThis}, that sums the elements of an array. If the first parameter is not an array, the function throws an error.

\begin{verbatim}
# Define a simple global function 'sumThis'.
engine %@% "
function sumThis(a) {
  if (!a.getClass().isArray())
    throw 'Not an array.';
  sum = 0;
  for (i = 0; i < a.length; i++) { 
      sum += a[i];
  }  
  return sum;
}
"

# Set the default length-one vectors setting so the example works as intended.
engine$setLengthOneVectorAsArray(FALSE)

# Call the function with a vector with length > 1.
vector <- c(1, 2, 3)
engine$invokeFunction("sumThis", vector)

## [1] 6

# If the vector is length-one, an error is thrown because an array parameter
# is expected.
vector <- 1
engine$invokeFunction("sumThis", vector)

## javax.script.ScriptException: Not an array. in <eval> at line number 4 at
## column number 4

# Try again, this time marking the vector as-is, meaning that it should 
# always be converted to an array.
vector <- 1
engine$invokeFunction("sumThis", I(vector))

## [1] 1
\end{verbatim}

The next example demonstrates using \code{invokeMethod}. It is essentially the same as \code{invokeFunction} except that the first two parameters require the object's name and method, respectively.

\begin{verbatim}
# Invoke the 'abs' (absolute value) method of the JavaScript 'Math' object.
engine$invokeMethod("Math", "abs", -3)

## [1] 3
\end{verbatim}

\subsection{String interpolation}

\pkg{jsr223} features string interpolation before code evaluation. R code placed between \code{@\{} and \code{\}} in a code snippet is evaluated and replaced by the a string representation of the return value before the snippet is executed by the script engine. A script may contain multiple \code{@\{...\}} expressions. String interpolation is enabled by default. It can be disabled using \code{engine\$setInterpolation(FALSE)}.

\strong{Note:} Interpolated decimal values may lose precision when coerced to a string.

This example simply sums two numbers. The section \hyperlink{callbacks}{Callbacks} includes a more interesting interpolation example involving recursion.

\begin{verbatim}
a <- 1; b <- 2
engine %~% "@{a} + @{b}"

## 3
\end{verbatim}

Interpolation expressions are evaluated in the current scope. The following example shows that interpolation locates the value defined in the function's scope before the global variable of the same name.

\begin{verbatim}
a <- 1

constantFunction <- function() {
  a <- 3
  engine %~% "@{a}"
}

constantFunction()

## [1] 3
\end{verbatim}

\hypertarget{callbacks}{\subsection{Callbacks}}

Embedded scripts can access the R environment using the \pkg{jsr223} callback interface. When a script engine is started, \pkg{jsr223} creates a global object named \code{R} in the script engine's environment. This object is used to execute R code and set/get variables in the R session's global environment.

This code example demonstrates setting and getting a variable in the R environment. For Ruby, remember to prefix the global variable \code{R} with a dollar sign.

\begin{verbatim}
engine %@% "R.set('a', [1, 2, 3])"
engine %~% "R.get('a')"

## [1] 1 2 3
\end{verbatim}

\strong{Note:} Changing any of the data exchange settings will affect the behavior of the callback interface. For example, using \code{engine\$setLengthOneVectorAsArray(TRUE)} will cause \code{R.get("pi")} to return an array with a single element instead of a scalar value.

Execute R script with \code{R.eval(script)} where \code{script} is a string containing R code. This example returns a single random normal draw from R.

\begin{verbatim}
set.seed(10)
engine %~% "R.eval('rnorm(1)')"

## [1] 0.01874617
\end{verbatim}

Infinite recursive calls between R and the script engine are supported. The only limitation is available stack space. The following code demonstrates recursive calls and string interpolation with a countdown.

\begin{verbatim}
recursiveCountdown <- function(start.value) {
  cat("T minus ", start.value, "\n", sep = "")
  if (start.value > 0)
    engine %~% "R.eval('recursiveCountdown(@{start.value - 1})');"
}

engine %~% "R.eval('recursiveCountdown(3)')"

## T minus 3
## T minus 2
## T minus 1
## T minus 0
\end{verbatim}

\subsection{Embedding R in another scripting language}

It is often desirable to use R as an embedded language. Though \pkg{jsr223} does not provide a standalone interface to call into R, the same functionality can be achieved with the \code{RScript} command line executable, a simple launch script, and the \pkg{jsr223} callback interface. The following R script is an example of a launch script for Groovy. It executes any Groovy script file provided as a command line parameter.

\begin{verbatim}
library("jsr223")
engine <- ScriptEngine$new("groovy", "../engines/groovy-all.jar")
tryCatch (
  engine$source(commandArgs(TRUE)[1], discard.return.value = TRUE),
  error = function(e) { cat(e$message, "\n", sep = "") },
  finally = { engine$terminate() }
)
\end{verbatim}

The following command line uses the launch script to execute a Groovy script. The launch script is named \samp{groovy-launcher.R} and \samp{source.groovy} is an arbitrary Groovy source file.

\begin{verbatim}
RScript groovy-launcher.R source.groovy
\end{verbatim}

With this setup, a developer can author a Groovy script in a dedicated script editor. The Groovy script can embed R using the \pkg{jsr223} callback interface as if it were a standalone interface. The command line above can be provided to a code editor to execute the Groovy script on demand. The Groovy code below is an example of embedding R.

\begin{verbatim}
// Set a variable named 'probabilities' in the R global environment.
R.set('probabilities', [0.25, 0.5, 0.20, 0.05]);

// Take a random draw of size two using the given probabilities.
draws = R.eval('sample(4, 2, prob = probabilities)');
\end{verbatim}

\subsection{Compiling script}

///mention that functions/methods are already compiled to bytecode.

The Java Scripting API supports compiling script to Java bytecode before evaluation. If unstructured code (i.e., code not encapsulated in methods or functions) is to be executed repeatedly, compiling it will improve performance.

\pkg{jsr223} supports compiling code snippets and source files. For the latter, local disk files or URLs can be specified. Both of these lines return a compiled script object:

\begin{verbatim}
cs <- engine$compile(script)
cs <- engine$compileSource(file.name)
\end{verbatim}

The compiled script object has a single method, \code{eval}, that is used to execute the compiled code. It can be argued that the method should be called \code{exec} in this case, but our interface follows the Java Scripting API naming scheme. The following trivial example demonstrates the compiled script interface.

\begin{verbatim}
# Compile a code snippet.
cs <- engine$compile("c + d")

# This line would throw an error because 'c' and 'd' have not yet been declared.
## cs$eval()

engine$c <- 2
engine$d <- 3
cs$eval()

## 5

# Supply new bindings...
lst <- list(c = 6, d = 7)
cs$eval(bindings = lst)

## 13

# When 'bindings' is not specified, the script engine reverts to the original
# environment.
cs$eval()

## 5

# The following line executes the code but discards the return value.
cs$eval(discard.return.value = TRUE)
\end{verbatim}

\subsection{Handling console output}

When script is evaluated, any text printed to standard output appears in the R console by default. Console output can be disabled entirely with \code{engine\$setStandardOutputMode('quiet')}. To resume printing output to the console, use \code{engine\$setStandardOutputMode('console')}.

Text printed to the console by a script engine cannot be captured using R's \code{sink} or \code{capture.output} methods. The following JavaScript example demonstrates how to capture output using the \textit{standard output mode} \code{'buffer'} option.

\begin{verbatim}
# Set output mode to 'buffer' to capture text written to standard output.
engine$setStandardOutputMode("buffer")

# The JavaScript print method writes text to standard output followed by a new
# line. This output will not appear in the R console; it will be stored in an
# internal buffer.
engine %@% ("print('abc');")

# 'getStandardOutput' retrieves the buffer as a character vector and clears the
# buffer.
engine$getStandardOutput()

## [1] "abc\n"

# Alternatively, the buffer can be discarded using 'clearStandardOutput'.
engine %@% ("print('abc');")
engine$clearStandardOutput()

# Restore console printing.
engine$setStandardOutputMode("console")

# The current output mode is retrieved using 'getStandardOutputMode'.
engine$getStandardOutputMode()

## [1] "console"
\end{verbatim}

\subsection{Console mode: a simple REPL}

\pkg{jsr223} provides a simple read-evaluate-print-loop (REPL) for interactive code execution. This feature is inspired by Jeroen Ooms's \pkg{V8} package. The REPL is useful for quickly setting and inspecting variables in the script engine. Returned values are printed to the console using \code{base::dput}. The \code{base::cat} function is not used because it cannot handle complex data structures.

Use \code{engine\$console()} to enter the REPL. Enter \samp{exit} to return to the R prompt. The REPL supports only single line entry: no line continuations or carriage returns are allowed. This limitation arises from the fact that the Java Scripting API does not support code validation.

The following output was produced by a Python REPL session. The code creates a Python dictionary object and accesses the elements. The tilde character (\samp{$\sim$}) indicates a prompt.

\begin{verbatim}
python console. Press ESC, CTRL + C, or enter 'exit' to exit the console.
~ dict = {"first": 1, "second": 2}

~ dict["first"]
1
~ dict["second"]
2
~ exit
Exiting console.
\end{verbatim}

Most developers are familiar with the command history in the R REPL.  Unfortunately, this feature is unreliable in the \pkg{jsr223} REPL because there is no standard for saving and restoring commands in R consoles.

\section{R with Groovy}

\href{http://www.groovy-lang.org/}{Groovy} is a dynamic programming language that closely follows Java syntax. The \pkg{jsr223} integration for Groovy enables developers to write solutions for R in natural Java syntax. Differences between Java and Groovy syntax are described in the Groovy guide “\href{http://groovy-lang.org/differences.html}{Differences with Java}” ///cite?.

\strong{Note:} In Groovy script, top-level variables will not persist in the script engine environment unless they are explicitly declared as global variables. Global variables are defined by omitting the type definition and Groovy's \code{def} keyword. For example \code{myValue = 42} will create a global variable. The \code{@myValue} notation cannot be used. To specify a data type for a global variable, use a constructor (\code{myVar = new Integer(42)}) or a type suffix (\code{myVar = 42L}).

\subsection{Groovy and Java Classes}

If you already know Java, using Java classes in Groovy will be very familiar. Java package members are imported (i.e., made accessible to the script) using the \code{import} statement. Groovy automatically imports many common Java packages by default such as \code{java.io.*}, \code{java.lang.*}, \code{java.net.*}, and \code{java.util.*}. If the package is not part of the JRE, add the package's JAR file to the \code{class.path} parameter of the \code{ScriptEngine\$new} constructor. \strong{Tip:} Supply class paths as separate elements of a vector instead of concatenating the paths with the usual path delimiters (“;” for Windows, and “:” for all others). This will help make your code platform-independent and easier to read.

This example uses the \href{http://commons.apache.org/proper/commons-math/}{Apache Commons Mathematics Library} ///cite? to sample from a bivariate normal distribution.

\begin{verbatim}
library("jsr223")

# Include both the Groovy script engine and the Apache Commons Mathematics 
# libraries in the class path. Specify the paths seperately in a character
# vector.
engine <- ScriptEngine$new(
  engine.name = "groovy",
  class.path = c("../engines/groovy-all.jar", "../commons-math3-3.6.1.jar")
)

# The getClassPath method displays the current class path.
engine$getClassPath()

# Define the means and covariance matrix that will be used to create the
# bivariate normal distribution.
engine$means <- c(0, 2)
engine$covariances <- diag(1, nrow = 2)

# Import the package member and instantiate a new class. For Groovy, excluding
# the type and 'def' keyword will make 'mvn' a global variable.
engine %@% "
  import org.apache.commons.math3.distribution.MultivariateNormalDistribution;
  mvn = new MultivariateNormalDistribution(means, covariances);
"

# Take a sample.
engine$invokeMethod("mvn", "sample")

## [1] 0.3279374 0.8652296

# Take three samples.
replicate(3, engine$invokeMethod("mvn", "sample"))

##           [,1]      [,2]      [,3]
## [1,] 0.9924368 -1.295875 0.2025815
## [2,] 2.5145855  2.128243 1.1666272

engine$terminate()
\end{verbatim}

\subsection{A Groovy web UI for editing R data frames}

///
%Example demonstrates harnessing Java in script. Java is great at simplifying multithreading, and here we have cross-platform GUI and HTML stuffs. Make it clear that this is an involved Java solution.

%doesn't handle empty data frames

%recommend running via command line so it shows up in foreground?

%warn that window comes up in background. see if we can do something about it or recommend it is execued from command line.

%///this example also shows how to use another web-based resource with R through a browser. you don't even have to show the browser. you can use the engine alone.
%
%Good example of implementing a somewhat involved Java solution with the quick-development cycle of a ///. We were able to take Java code examples and implement it in Groovy. It is possible to reproduce this example in any of the other \pkg{jsr223}-supported language.
%Java stuff 
%
%The Java platform includes a browser component called \code{WebView} that is based upon the widely-used open source engine \href{https://webkit.org/}{WebKit}///cite?. \code{WebView} is fully programmable, allowing developers to automate interactions with web content and user input.
%
%The following Groovy example example launches 
%
%///handsontable and dependencies may take a while to load the first time.
%
%\href{http://docs.oracle.com/javafx/2/webview/jfxpub-webview.htm}{Adding HTML Content to JavaFX Applications}

\section{R with JavaScript}

The popularity of JavaScript has overflowed the arena of web development into standalone solutions involving databases, charting, machine learning, and network-enabled utilities, to name just a few. Many of these solutions can be harnessed by R with the help of \pkg{jsr223}. Even browser-based scripts that require a document object model (DOM) can be executed using Java's \code{WebView} browser. ///(See ///“A Groovy web UI for editing R data frames” for \code{WebView} details.) Popular JavaScript solutions can be found at \href{https://www.javascripting.com/}{JavaScripting}, an online database of JavaScript solutions. \href{https://github.com/trending/javascript?since=monthly}{Github} also lists trending solutions for JavaScript, as well as other languages.

\href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Nashorn} is the JavaScript dialect included in Java 8. Nashorn implements ECMAScript 5.1. No download is required to use JavaScript with \pkg{jsr223}. Technical documentation and examples are available at \href{https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/}{Oracle's Nashorn web site} ///cite?.

\subsection{JavaScript and Java classes}

JavaScript Nashorn provides wide support for Java classes, including the ability to extend classes and implement interfaces. Nashorn provides several methods to reference JavaScript classes. The two most common methods are demonstrated below. This code uses a static class method to sort a vector of integers.

\begin{verbatim}
# The method recommended by Nashorn: create a reference to a Java class using
# the built-in Java.type() method. Conceptually, this is similar to importing
# the class.

engine %~% "
var Arrays = Java.type('java.util.Arrays');
var random = R.eval('sample(5)');
Arrays.sort(random);
random;
"

## [1] 1 2 3 4 5

# An alternative method uses the a fully qualified class name, but it
# requires more overhead per call.

engine %~% "
var random = R.eval('sample(5)');
java.util.Arrays.sort(random);
random;
"

## [1] 1 2 3 4 5
\end{verbatim}

The \code{Java.type()} method is required to create Java primitives as demonstrated in this example:

\begin{verbatim}
# Create a Java integer array with five elements.
var IntegerArrayType = Java.type('int[]');
var myArray = new IntegerArrayType(5); 
\end{verbatim}

We reproduce the bivariate normal example in JavaScript to demonstrate importing an external library and to point out an important limitation in Nashorn regarding \code{invokeMethod}.

\begin{verbatim}
library("jsr223")

# Include the Apache Commons Mathematics library in class.path.
engine <- ScriptEngine$new(
  engine.name = "js",
  class.path = "../commons-math3-3.6.1.jar"
)

# Define the means and covariance matrix that will be used to create the
# bivariate normal distribution.
engine$means <- c(0, 2)
engine$covariances <- diag(1, nrow = 2)

# Import the package member and instantiate a new class.
engine %@% "
var MultivariateNormalDistributionClass = Java.type(
  'org.apache.commons.math3.distribution.MultivariateNormalDistribution'
);
var mvn = new MultivariateNormalDistributionClass(means, covariances);
"

# This line would throw an error. Nashorn JavaScript supports 'invokeMethod' for
# native JavaScript objects, but not for Java objects.
# 
## engine$invokeMethod("mvn", "sample")

# Instead, use script...
engine %~% "mvn.sample();"

## [1] 0.3279374 0.8652296

# ...or wrap the method in a JavaScript function.
engine %@% "function sample() {return mvn.sample();}"
engine$invokeFunction("sample")

## [1] 0.2527757 1.1942332

# Take three samples.
replicate(3, engine$invokeFunction("sample"))

##           [,1]      [,2]      [,3]
## [1,] 0.9924368 -1.295875 0.2025815
## [2,] 2.5145855  2.128243 1.1666272

engine$terminate()
\end{verbatim}

\subsection{Using JavaScript solutions - Voca}

\href{https://vocajs.com/}{Voca} ///cite? is a popular library that simplifies many difficult string manipulation tasks such as word wrapping and diacritic detection (e.g., the “\'{e}” caf\'{e}). Using Voca with \pkg{jsr223} is simply a matter of sourcing a single script file. This sample script loads Voca and demonstrates its functionality.

\begin{verbatim}
# Source the Voca library. This creates a utility object named 'v'.
engine$source("./voca.min.js", discard.return.value = TRUE)

# 'prune' truncates string, without break words, ensuring the given length, including
# a trailing "..."
engine %~% "v.prune('A long string to prune.', 12);"

## [1] "A long..."

# Provide a different suffix to 'prune'.
engine %~% "v.prune('A long string to prune.', 16, ' (more)');"

## [1] "A long (more)"

# Voca supports method chaining.
engine %~% "
v('Voca chaining example')
  .lowerCase()
  .words()
"

## [1] "voca"     "chaining" "example"

# Split graphemes.
engine %~% "v.graphemes('cafe\u0301');"

## [1] "c" "a" "f" "é"

# Word wrapping.
engine %~% "v.wordWrap('A long string to wrap', {width: 10});"

## [1] "A long\nstring to\nwrap"

# Word wrapping with custom delimiters.
engine %~% "
v.wordWrap(
  'A long string to wrap',
  {
    width: 10,
    newLine: '<br/>',
    indent: '__'
  }
);
"

## [1] "__A long<br/>__string to<br/>__wrap"
\end{verbatim}

\section{R with Python}

Like R, the \href{https://www.python.org/}{Python} programming language is used widely in science and analytics. Python has a remarkably broad set of features, yet it is also known for being concise and easy to read. The \href{http://www.jython.org/}{Jython} project has migrated Python to the Java platform. Support for popular native libraries such as NumPy and SciPy are underway in a related project \href{http://www.jyni.org/}{JyNI} (the Jython Native Interface).

\strong{Note:} Leading white space is significant in Python; it is used to delimit code blocks. Avoid syntax errors by left-aligning code in multi-line string snippets as shown in the examples that follow.

\subsection{Python and Java classes}

To create a Java object in Python, simply import the associated package and call the class constructor. The \href{https://wiki.python.org/jython/NewUsersGuide}{Jython User Guide} provides further details for using Java classes. This example generates a random number using the \code{java.util.Random} class.

\begin{verbatim}
# Create an object from the java.util.Random class.
engine %~% "
from java.util import Random
r = Random(10)
"

# Jython supports invoking Java methods.
engine$invokeMethod("r", "nextDouble")

## [1] 0.7304303
\end{verbatim}

Jython's \code{jarray} module is required to create native Java arrays. It has two methods: \code{array(sequence, type)} and \code{zeros(length, type)}. The \code{array} method copies a Python sequence to a Java array of the given type. The \code{zeros} method initializes a Java array of the requested type with zero or \code{null}.

\begin{verbatim}
# Use 'jarray.array' to copy a sequence to a Java array of the requested type.
engine %~% "
from jarray import *
myArray = array([3, 2, 1], 'i')
"
engine$myArray

## [1] 3 2 1

# Alternatively, use zeros to initialize an array with zeros or null. This
# example allocates an array and udpates the values with a loop.
engine %~% "
myArray = zeros(5, 'i')
for i in range(myArray.__len__()):
  myArray[i] = i
"
engine$myArray

## [1] 0 1 2 3 4
\end{verbatim}

\subsection{A simple Python HTTP server}

This code sample creates a basic HTTP server in Python that calls R to produce HTML content. The Python script listed here defines two classes. The \code{MyHandler} class processes HEAD and GET requests for the server. The \code{MyServer} class is used by the R script to start and stop the web server. The Python code is adapted from the \href{https://wiki.python.org/moin/BaseHttpServer}{Python Wiki}.

%///test this code with line-wrapping enabled
\begin{verbatim}
import time
import BaseHTTPServer

# HTTP request handler class
class MyHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    def do_HEAD(s):
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()
    def do_GET(s):
        print time.asctime(), "Received request"
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()
        s.wfile.write("<html><head><title>R/Python HTTP Server</title></head>")
        html = R.eval('getHtmlTable()') # Get HTML table from R.
        s.wfile.write(html)
        s.wfile.write("</body></html>")

class MyServer:
    def __init__(self, host_name, port_number, timeout):
        self.host_name = host_name
        self.port_number = port_number
        server_class = BaseHTTPServer.HTTPServer
        self.httpd = server_class((self.host_name, self.port_number), MyHandler)
        self.httpd.timeout = timeout
        print time.asctime(),
            "Server Starts - %s:%s" % (self.host_name, self.port_number)
    def handle_request(self):
        # This method exists only for demonstration purposes. For a production 
        # scenario, see 'SocketServer.serve_forever()'.
        self.httpd.handle_request()
    def close(self):
        self.httpd.server_close()
        print time.asctime(),
            "Server Stops - %s:%s" % (self.host_name, self.port_number)
\end{verbatim}

The R script sources the Python script above and starts the web server. It also defines \code{getHtmlTable}: a function that generates HTML content for the web server. For demonstration purposes, the R script shuts down the Python web server automatically after 60 seconds. Run the R script and point a web browser to \url{http://127.0.0.1:8080} to see the result.

\begin{verbatim}
library("xtable")
library("jsr223")

server.runtime = 60 # Seconds before the HTTP server shuts down.

# Format the iris data set as an HTML table. This function will be called from
# the Python web server in response to an HTTP GET request.
getHtmlTable <- function() {
  t <- xtable(iris, "Iris Data")
  html <- capture.output(print(t, type = "html", caption.placement = "top"))
  paste0(html, collapse = "\n")
}

# Start the python engine.
engine <- ScriptEngine$new(
  engine.name = "python",
  class.path = "../engines/jython-standalone.jar"
)

# Source the Python script.
engine$source("./python-http-server.py", discard.return.value = TRUE)

runServer <- function() {
  # Automatically shut down server when this function exits.
  on.exit(
    {
      engine$invokeMethod("server", "close")
      engine$terminate()
    }
  )
  
  # Create an instance of Python 'MyServer' class which starts the server at the
  # specified port with the given request timeout in seconds. A timeout would 
  # not be used in a production scenario.
  engine %@% "server = MyServer('localhost', 8080, 2)"
  
  # Handle requests for 'server.runtime' seconds before shutting down. The 
  # 'handle_request' method waits for the timeout specified in the 'MyServer' 
  # constructor before returning to the event loop to allow interruptions. In a
  # production scenario, the R side would not be involved in monitoring 
  # requests. See Python's 'SocketServer.serve_forever()' for more information.
  started <- as.numeric(Sys.time())
  while(as.numeric(Sys.time()) - started < server.runtime)
    engine$invokeMethod("server", "handle_request")
}

runServer()
\end{verbatim}

\section{R with Ruby}

The \href{https://www.ruby-lang.org}{Ruby} programming language is a general-purpose, object-oriented programming language invented by Yukihiro Matsumoto. According to Matsumoto, he designed the language to “help every programmer in the world to be productive, and to enjoy programming, and to be happy” ///cite. \href{http://jruby.org/}{JRuby} is a Java implementation of the Ruby language. JRuby is compatible with the popular web application framework \href{http://rubyonrails.org/}{Ruby on Rails}.

%///https://www.youtube.com/watch?v=oEkJvvGEtB4

\strong{Note:} Global variables in Ruby script must be prefixed with a dollar sign. Hence, if we create a variable \code{myValue} using a \pkg{jsr223} assignment (e.g., \code{engine\$myValue <-\, 10}), it is accessed in Ruby script as \code{\$myValue}. Do not use the dollar sign prefix when accessing global variables via \pkg{jsr223} methods (e.g., \code{engine\$get("myValue")}).

\strong{Note:} We have observed a bug in JRuby's exception handling: when JRuby encounters an error, the engine may continue to throw errors erroneously in subsequent evaluation requests. If this happens, restart the script engine.

\subsection{Ruby and Java classes}

JRuby implements several methods to access Java classes in Ruby syntax. For a comprehensive guide, see \href{https://github.com/jruby/jruby/wiki/CallingJavaFromJRuby}{Calling Java from JRuby}. We demonstrate the most intuitive syntax using the multivariate normal random sampler.

\begin{verbatim}
library("jsr223")

# Include both the JRuby script engine and the Apache Commons Mathematics
# libraries in the class path. Specify the paths seperately in a character
# vector.
engine <- ScriptEngine$new(
  engine.name = "ruby", 
  class.path = c(
    "../engines/jruby-complete.jar",
    "../commons-math3-3.6.1.jar"
  )
)

# Define the means and covariance matrix that will be used to create the 
# bivariate normal distribution.
engine$means <- c(0, 2)
engine$covariances <- diag(1, nrow = 2)

# Import the class and create a new object from the class.
engine %@% "
java_import org.apache.commons.math3.distribution.MultivariateNormalDistribution
$mvn = MultivariateNormalDistribution.new($means, $covariances)
"

# This line would throw an error. JRuby supports 'invokeMethod' for
# native Ruby objects, but not for Java objects.
# 
## engine$invokeMethod("mvn", "sample")

# Instead, use script...
engine %~% "$mvn.sample()"

## [1] 0.3279374 0.8652296

# ...or wrap the method in a function.
engine %@% "
def sample()
  return $mvn.sample()
end
"
engine$invokeFunction("sample")

## [1] 0.2527757 1.1942332

# Take three samples.
replicate(3, engine$invokeFunction("sample"))

##           [,1]      [,2]      [,3]
## [1,] 0.9924368 -1.295875 0.2025815
## [2,] 2.5145855  2.128243 1.1666272

engine$terminate()
\end{verbatim}

\hypertarget{usingrubygems}{\subsection{Using Ruby gems}}

Ruby libraries and programs are distributed in a standardized package format called a \textit{gem}. We demonstrate using gems in \pkg{jsr223} with Ty Rauber's \href{https://github.com/tyrauber/stock_quote}{\code{stock\_quote}} gem ///cite?. 

A full installation of JRuby is required to use gems. Install JRuby and the \code{stock\_quote} gem using the instructions found in \href{https://github.com/jruby/jruby/wiki/GettingStarted}{Getting Started with JRuby}.%///cite? 

To access \code{stock\_quote} with \pkg{jsr223}, the paths to the gem and its dependencies must be added to the \code{ScriptEngine\$new} class path. These paths can be discovered using the JRuby REPL, \code{jirb}, as shown here.

\begin{verbatim}
me@ubuntu:~$ jirb
irb(main):001:0> require 'stock_quote'
=> true
irb(main):002:0> puts $LOAD_PATH
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/unf-0.1.4-java/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/domain_name-0.5.20160826/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/http-cookie-1.0.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/mime-types-2.99.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/netrc-0.11.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/rest-client-1.8.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/stock_quote-1.2.3/lib
~/jruby-9.1.5.0/lib/ruby/2.3/site_ruby
~/jruby-9.1.5.0/lib/ruby/stdlib
=> nil
irb(main):003:0> exit
\end{verbatim}

Supply the resulting paths to the \code{class.path} parameter of the \pkg{jsr223} \code{ScriptEngine\$new} method. In our experience, the \samp{site\_ruby} path did not exist. If \code{ScriptEngine\$new} throws an error indicating a path does not exist, simply exclude it from the class path.

The code sample below downloads closing price history for two stocks and displays them in a combined time series plot (Figure \ref{fig:stocks}). The R packages \CRANpkg{jsonlite} ///cite and \CRANpkg{ggplot2} ///cite are required. %///Maybe do without jsonlite///

\begin{figure}[h]
\centering
\includegraphics[width=1\linewidth]{graphics/stocks}
\caption{Plot of closing stock prices produced by data obtained using Ty Rauber's \code{stock\_quote} Ruby gem.}
\label{fig:stocks}
\end{figure}

\begin{verbatim}
library("jsr223")
library("jsonlite")
library("ggplot2")

# In addition to the script engine JAR, include all of the required gem paths in
# the class path. In this case, we use 'jruby.jar' from the full installation 
# instead of the standalone script engine JAR file.
# 
# The gem paths were obtained by running the JRuby REPL 'jirb' in the terminal
# and executing the following two commands:
# 
# require 'stock_quote'
# puts $LOAD_PATH

class.path <- "
~/jruby-9.1.5.0/lib/jruby.jar
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/unf-0.1.4-java/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/domain_name-0.5.20160826/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/http-cookie-1.0.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/mime-types-2.99.3/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/netrc-0.11.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/rest-client-1.8.0/lib
~/jruby-9.1.5.0/lib/ruby/gems/shared/gems/stock_quote-1.2.3/lib
~/jruby-9.1.5.0/lib/ruby/stdlib
"
class.path <- unlist(strsplit(class.path, "\n", fixed = TRUE))

engine <- ScriptEngine$new(
  engine.name = "jruby",
  class.path = class.path
)

# Import the required Ruby libraries.
engine %@% "
require 'date'
require 'stock_quote'
"

# Print some real-time stock data to the console.
engine %@% "
$stock = StockQuote::Stock.quote('AEPGX')
puts $stock.name, $stock.change
"

# Ruby function to retrieve a year of closing stock prices for a given symbol in
# JSON format.
engine %@% "
def getStockYear(symbol)
  end_date = Date.today
  start_date = end_date.prev_year
  h = StockQuote::Stock.history(
    symbol,
    start_date = start_date,
    end_date = end_date,
    select = 'Close, Date',
    format = 'json'
  )
  return JSON.generate(h.fetch('quote'))
end
"

# R function wrapper to convert the Ruby JSON result to a data frame.
getStockYear <- function(symbol) {
  json <- engine$invokeFunction("getStockYear", symbol)
  df <- jsonlite::fromJSON(json)
  df$Close <- as.numeric(df$Close)
  df$Date <- as.POSIXct(df$Date)
  df
}

# Get closing values as data frames for two stocks.
aepgx <- getStockYear("AEPGX")
agthx <- getStockYear("AGTHX")

# Graph the closing values via 'ggplot2'.
ggplot() +
  geom_line(data = aepgx, aes(x = Date, y = Close, color = "AEPGX")) +
  geom_line(data = agthx, aes(x = Date, y = Close, color = "AGTHX")) +
  ggtitle("Closing Stock Prices: AEPGX, AGTHX") +
  theme(legend.position = c(0.1, 0.9), legend.title = element_blank()) +
  labs(x = "Date", y = "Closing Price")

engine$terminate()
\end{verbatim}

\section{\pkg{jsr223} package design}

///
%Mention a little bit about supporting generic interfaces for data instead of custom R classes.

\section{\pkg{jsr223} API}

///

\section{Data interchange}
%///review these notes, but remove this section

///
%Mention a little bit about supporting generic interfaces for data instead of custom R classes.
%Generic Collections and Maps are supported, giving us almost everything. There are some specific conversions for ///Ruby, for example///. Speicifics for collections.

%Talk about the problems of converting collections, and where collections are used. For example, JavaScript's arrays are actually collections. These must be detected. Integers must be separated from arrays.

%///
%Collection interface covers many typical data structures in serveral different languages including ArrayList, etc.

\section{Limitations and known issues}

///

% \strong{Note:} The Groovy and Python engines support using \code{engine\$invokeMethod()} to call methods of Java objects. JavaScript and Ruby do not.

%///\pkg{jsr223} is not strictly threadsafe.

%///callbacks must be on the original thread. is this true? it might not be. if there is a limitation, note it here and in callbacks.

%///classpaths remain loaded after closing an engine. This is \pkg{rJava}. Restart R.
%///if something complains “Failed to instantiate engine 'python'. Make sure the engine dependencies are in the class path.”, restart R. It is a class path issue.

%///\section{Package version history}

%///\section{Document version history}

\section{Conclusion}

%///people can use tools they know. Java is very accessible.
///

\clearpage

\bibliography{gilbert-dahl}

\address{Floid R. Gilbert\\
    Department of Statistics\\
    Brigham Young University\\
    Provo, UT 84602\\
    USA\\}
\email{floid.r.gilbert@gmail.com}

\address{David B. Dahl\\
    Department of Statistics\\
    Brigham Young University\\
    Provo, UT 84602\\
    USA\\}
\email{dahl@stat.byu.edu}

