Problems Solved by using rJava
	Faster execution in general, and faster callbacks
	Far simpler code base and support
	Far simpler documentation
	No more problems with stdout (buffer clearing and all that) I think. Try it with multithreading to be sure.
		I wonder what this will do for Scala.
	No debugging interface necessary
		No more difference between Windows/Other functionality.
	No JSON overhead
	Not necessary to handle R interrupts or code exceptions.
	No more JSON limitations 
		like floating point differences (check)
		unicode
	No more R TCP/IP issues (though we still need to report their sockets bug)
	No separate executable so no chance of abandoning running process
	
Problems Created by using rJava
	Without JSON, it might be difficult to return values to R. Will we need to implement mirroring or some kind of rules?

Problems Avoided
	Because we aren't using JRI (I think), we don't have to worry about shlib issues. Not sure if 
		we are giving anything up. This could be a problem overall. May need to learn it anyway. Still, the 
		installation documentation for JRI looks like a pain. Lots of paths required.  

R Interface and functionality
	Learn to use R6 or RC.	
		Why? Because we are currently mixing OOP and S3 styles. Not a good thing.
	Consider using methods only, instead of $ and %~% to be more clear. $<- is legitimately confusing
		because it doesn't show up in the list anymore.
	Consider distributing or enabling downloads for script engines so we don't have to mess around with
		class paths. Could just handle it for the user. Probably not a good idea because automating this 
		would not be easy unless the paths never change. I would have to stick with a given release potentially
		unless I set up my own server that served the download paths. Fun idea, but nah...could we use maven
		or something for this functionality I wonder?
	

Boolean	
Byte	
Character	
Double	
Float	
Integer	
Long	
Number	
Object	
Short	
String	

Arrays of all of these
We only see SOM if it isn't a scalar value (usually an array).
Maps > SOMs > Collections
	
Rules for Data Conversion
Scalars are scalars. 
	Booleans are themselves.	
	Byte, Short, Integer are integers.
	Double, Float, Long are numeric/double.
	Character and String are character vectors.
	Dates are converted to strings?
	Homogeneous arrays of 1D and 2D are themselves
	Maps are converted to dfs or lists.
	SOMs are JS arrays that will be converted to arrays or lists, depending, but never dfs.
	Collections, like SOMs, will be converted to arrays or lists, depending, but never dfs.

If Map
	If SOM
		// Convert to native array or list.
		Pass collection to collection function.
	Else
		// Convert to native array or named/unnamed list or df
	End If
Else If Collection
	// Convert to native array or list
	Try to convert to native array based on type of first value.
	Else, go through each item and do J2R on it, saving it in list style object arrays.
End If



check first item to see if it is a scalar, simple value. if it is, try to convert the rest to the same.

