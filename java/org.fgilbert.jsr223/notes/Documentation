There may be no memory separation between engine instances.
What is the multi-threading safety status?

See installation for rJava, may need to execute R CMD WHATEVER

Describe how/what is supported for data frames. All arrays contained in a Map must be 1D and of supported types x, y, z.

For those languages that return values when you don't want them, use %@%.

Recommend to the user to support higher dimension arrays to pass them and reconstruct matrices one at a time to R.

Factors are converted to vectors. This includes factors in dataframes.

1D Arrays are coerced to vectors, so they will come back as vectors (like factors).

When building data frames, items are recycled if the arrays are not all the same length. Actually, I am going to change
this to raise an error or to create a list when this happens.

Empty JS arrays, empty collections, and empty maps result in an empty R list.

Also give shoutout to rJava team.

Rules for coercing map, som, col. Note that this is difficult because JS arrays (and any other associative? arrays) can be thought of as vectors or lists depending on the content.

BigInts and Big* types are not supported. make sure they error in every case.

Note how Maps can be used with keys like methods/fields. However, if it is an improper name (like a number), you must access it with the standard methods.

private$strings.as.factors = NULL # NULL means to use system default

go back to boolean, but tell the world that NAs are not preserved. explain the behavior
of NA, NaN, etc. for each R type. FOr boolean it will be NA = true with a warning.

NA and NaN are preserved. Explain the whats?

why when I send an integer array does it show up as double in JS? is that okay?

Suggest avoiding R arrays. no good reason to use them. is just slower.

#///tell people to disable interpolation to improve loop performance...if it is really a factor. test it.

Known issue: when length one vector... is false, character NA is returned as NULL.

Use LinkedHashMap or whatever it's called instead of HashMap if you want cols to be returned in order.

Maps of length zero/one are lists. Maps of length > 1 with vectors (not scalars) of the same size are data frames.
A named list of same-length vectors will be returned as a data frame.
If you set data.frame() you get back list().
unnamed lists may come back as vectors, matrices, etc. recommend using named lists.

row names are not preserved for any objects. names not preserved for vectors. only columns/list names are preserved.

# If an unnamed list (or any other collection) contains homogeneous scalars, it
# will be converted to a vector.

setlengthonevectorasarray affects lists, right?

ragged arrays are converted to lists.

Java to R
	byte scalars are integers. byte 1d arrays are raw. byte 2d arrays are integers.
	byte collections are also raw.
R to Java
	raw is always byte array, never byte scalar. lengthoneasarray has no effect.
# Don't be tempted to do this. raw vectors are always interpreted as byte
# arrays, even if they are length one. as.list(as.raw(1:20)) will create a list
# with twenty byte array members of length one, not scalars. Therefore, it will
# be interpreted as an array, which is not supported for raw values.
# v <- as.raw(1:20)
# setGetValues(list(as.list(v)), list(v))

# If an unnamed list (or any other collection) contains scalars, it
# will be converted to a vector if the types as follows:
# If the contents are all number types, a byte/raw, integer, numeric
# vector will be returned depending on the most general number type.
# If the contents contains character/string, a character vector will
# be returned.
# Finally, if characters/numbers are mixed, a list will be returned,
# not a character vector.
# This behavior was chosen because JS (possibly other script langs)
# use collections for their array types.
	 * Attempts to convert a collection of scalars to a one-dimensional array. Returns false
	 * if it fails to do so. The conversions are as follows.
	 * Mix of Byte, null -> byte array
	 * Mix of Integer, Short, Byte, null -> integer array
	 * Mix of Double, Long, Float and all other Number types -> double array
	 * Mix of String, Character, null -> String array
	 * Mix of Boolean, null -> boolean array

explain why raw matrices are not supported (because Java byte matrices make more sense coming back as integer matrices in R)
	
collections are converted to matrices only if the vectors are all the same data type. it will not try to go from specific to general like others.	

Do not try to catch warnings. Use suppresswarnings instead. If you catch warnings, you will break everything.

Document that lengthoneasarray does not affect raw types.

# Empty and one-column data frames come back as lists.

only strings are supported for map keys.

note how setlengthoneasarray affects lists.
if true, list(a = 1, b = 2, c = 3) will come back as a df.
if false, comes back as a list of scalars.

consider documenting filling matrices by row to be more ??? with java.

js %@% "R.eval('cat(123)')" cannot be captured by buffered mode.

document how to set the java heap size with options(java.parameters = ).

dataframe of 1 col will come back as a named list. known limitation.

document options to change jvm parameters.

note that passing bindings to any eval function slows things down...depending on how many variables you want to set.

note in paper and elsewhere that types are preserved from R. 1 will be double while 1L will be numeric. Nice.

Should I document that... Or is it only JS?
java.lang.IllegalArgumentException: getInterface cannot be called on non-script object 

for languages that return the value of a defined thing, need to figure out how to ignore returning an uknown type when declaring functions or tell user to use %@%

tell them to download the jruby complete jar

see the other todo list in the temp folder

all Ruby integers come back as numeric because they are long...larger than the R integer...verify.
tell people to convert RubyRange with to_a...or continue to play with it. see how it works.
cannot re-use the same variable for a different type. it keeps its type...I think. is this a bug?
bugs to report
	standard output
	errors stay out there after they start happening
	when restarting engine, bindings remain
	bigdecimal doesn't work right. get errors when comparing or getting class type


dropping support for scala. the JSR223 implementation can't
	handle standard out
	support bindings
	support set/get
	doesn't play nicely with rJava load classpath, would require CLASSPATH environment variable which is a mess.
	
	
note that js$setLengthOneVectorAsArray(FALSE) affects R.eval and R.get as well as engine$set

console history does not work as expected in a lot of cases...sorry. not sure what to do about it.
explain why multi-line commands are not allowed. inform David...
	can't do a validation because of side effects... very dangerous. I can only execute. I can't execute it without bindings because there can still be side-effects and I will get errors for identifiers.
	
	
	\itemize{
  \item \code{class.path} -- Read-only character vector containing the JAR files passed to the jjs executable via the \dQuote{-J-Djava.class.path=} command line parameter. The jjs executable launches the JVM which hosts the script engine environment.

  \item \code{debug.client} -- Read-write logical vector of length one. Default \code{FALSE}. If set to \code{TRUE}, messages sent/received by \pkg{jsr223} in the \R session (the client) are printed in the \R console. Messages are in JSON format.

  \item \code{debug.server} -- Read-write logical vector of length one. Default \code{FALSE}. If set to \code{TRUE}, messages sent/received by the script engine manager (the server) are printed in the \R console. Messages are in JSON format. NOTE: This feature is not supported on the Windows platform.

  \item \code{engine.name} -- Read-only character vector of length one. Returns the short name used to instantiate the engine.

  \item \code{interpolate} -- Read-write logical vector of length one. Default \code{TRUE}. When \code{TRUE}, string interpolation of code snippets is enabled. That is, \R code bracketed in '@\{\}' is evaluated and replaced before the snippet is evaluated by the script engine.

  \item \code{jjs.arguments} -- Read-only named list containing the command line arguments passed to the jjs executable. The jjs executable launches the JVM which hosts the script engine environment.

  \item \code{jjs.executable} -- Read-only character vector of length one. Returns the full path to the jjs executable used to start the JVM and host the script environment. This can be used to determine which Java Run-time Environment installation is being used.

  \item \code{length.one.vector.as.array} -- Read-write logical vector of length one. Default \code{FALSE}. When \code{FALSE}, passing a vector of length one to the script engine will result in a scalar value. When \code{TRUE}, passing a vector of length one to the script engine will result in a 1x1 array.

  \item \code{quiet} -- Read-write logical vector of length one. Default \code{FALSE}. When \code{FALSE}, text written by the script engine to standard output will be printed in the \R console. When \code{TRUE}, output will not be printed in the console. NOTE: The Scala engine does not currently support this feature.

  \item \code{server.port} -- Read-only numeric vector of length one. Returns the local server port used to communicate with the engine instance.

  \item \code{timeout} -- Read-only numeric vector of length one. Returns the connection timeout specified when the engine instance was created.

  \item \code{xboot.class.path} -- Read-only character vector containing the JAR files passed to the jjs executable via the \dQuote{-J-Xbootclasspath/a:=} command line parameter. The jjs executable launches the JVM which hosts the script engine environment.
}

\code{\link{isEngineOpen}} returns a logical value indicating whether the engine instance is open.
	
	